{"meta":{"title":"xc4ll0c","subtitle":"biu biu biu","description":null,"author":"wenZheng zhang","url":"http://yoursite.com"},"pages":[{"title":"about","date":"2017-12-08T03:02:16.000Z","updated":"2017-12-08T03:03:44.161Z","comments":true,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":""},{"title":"categories","date":"2017-12-08T03:02:05.000Z","updated":"2017-12-08T03:03:05.158Z","comments":true,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2017-12-08T03:01:45.000Z","updated":"2017-12-08T03:03:33.430Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"记一次Signal 5崩溃定位（NotDone）","slug":"DebugSignal5Crash","date":"2017-12-08T03:31:45.000Z","updated":"2017-12-08T07:53:36.829Z","comments":true,"path":"2017/12/08/DebugSignal5Crash/","link":"","permalink":"http://yoursite.com/2017/12/08/DebugSignal5Crash/","excerpt":"","text":"崩溃栈123456789101112131415161718192021222324252627* 1 libdispatch.dylib 0x180506bb0 __dispatch_queue_resume + 624* 2 CoreFoundation 0x18160e22c ___CFNOTIFICATIONCENTER_IS_CALLING_OUT_TO_AN_OBSERVER__ + 20* 3 CoreFoundation 0x18160e22c ___CFNOTIFICATIONCENTER_IS_CALLING_OUT_TO_AN_OBSERVER__ + 20* 4 CoreFoundation 0x18160d930 __CFXRegistrationPost + 400* 5 CoreFoundation 0x18160d6ac ____CFXNotificationPost_block_invoke + 60* 6 CoreFoundation 0x18167cb9c -[_CFXNotificationRegistrar find:object:observer:enumerator:] + 1504* 7 CoreFoundation 0x18154fbf4 __CFXNotificationPost + 376* 8 Foundation 0x1820566bc -[NSNotificationCenter postNotificationName:object:userInfo:] + 68* 9 UIKit 0x18771d9d8 -[UIApplication _sendWillEnterForegroundCallbacks] + 232* 10 UIKit 0x187758ebc -[UIApplication _handleApplicationActivationWithScene:transitionContext:completion:] + 2140* 11 UIKit 0x1877583ec -[UIApplication _handleApplicationLifecycleEventWithScene:transitionContext:completion:] + 452* 12 UIKit 0x187743ae8 ___70-[UIApplication scene:didUpdateWithDiff:transitionContext:completion:]_block_invoke + 152* 13 UIKit 0x18774376c -[UIApplication scene:didUpdateWithDiff:transitionContext:completion:] + 888* 14 UIKit 0x187a75034 -[UIApplicationSceneClientAgent scene:handleEvent:withCompletion:] + 464* 15 FrontBoardServices 0x1831e7bd4 &lt;redacted&gt;* 16 FrontBoardServices 0x183215904 &lt;redacted&gt;* 17 FrontBoardServices 0x183215770 &lt;redacted&gt;* 18 FrontBoardServices 0x183215b18 &lt;redacted&gt;* 19 CoreFoundation 0x181622278 ___CFRUNLOOP_IS_CALLING_OUT_TO_A_SOURCE0_PERFORM_FUNCTION__ + 24* 20 CoreFoundation 0x181621bc0 ___CFRunLoopDoSources0 + 524* 21 CoreFoundation 0x18161f7c0 ___CFRunLoopRun + 804* 22 CoreFoundation 0x18154e048 _CFRunLoopRunSpecific + 444* 23 GraphicsServices 0x182fd1198 _GSEventRunModal + 180* 24 UIKit 0x187527818 -[UIApplication _run] + 684* 25 UIKit 0x187522550 _UIApplicationMain + 208* 26 App 0x1005d3268 _main (main.m:16)* 27 libdyld.dylib 0x1805305b8 _start + 4 信息收集先确定下signal 5崩溃的原因是啥，signal.h定义的signal如下： 12345678910111213141516171819202122232425262728293031323334353637383940#define SIGHUP 1 /* hangup */#define SIGINT 2 /* interrupt */#define SIGQUIT 3 /* quit */#define SIGILL 4 /* illegal instruction (not reset when caught) */#define SIGTRAP 5 /* trace trap (not reset when caught) */#define SIGABRT 6 /* abort() */#if (defined(_POSIX_C_SOURCE) &amp;&amp; !defined(_DARWIN_C_SOURCE))#define SIGPOLL 7 /* pollable event ([XSR] generated, not supported) */#else /* (!_POSIX_C_SOURCE || _DARWIN_C_SOURCE) */#define SIGIOT SIGABRT /* compatibility */#define SIGEMT 7 /* EMT instruction */#endif /* (!_POSIX_C_SOURCE || _DARWIN_C_SOURCE) */#define SIGFPE 8 /* floating point exception */#define SIGKILL 9 /* kill (cannot be caught or ignored) */#define SIGBUS 10 /* bus error */#define SIGSEGV 11 /* segmentation violation */#define SIGSYS 12 /* bad argument to system call */#define SIGPIPE 13 /* write on a pipe with no one to read it */#define SIGALRM 14 /* alarm clock */#define SIGTERM 15 /* software termination signal from kill */#define SIGURG 16 /* urgent condition on IO channel */#define SIGSTOP 17 /* sendable stop signal not from tty */#define SIGTSTP 18 /* stop signal from tty */#define SIGCONT 19 /* continue a stopped process */#define SIGCHLD 20 /* to parent on child stop or exit */#define SIGTTIN 21 /* to readers pgrp upon background tty read */#define SIGTTOU 22 /* like TTIN for output if (tp-&gt;t_local&amp;LTOSTOP) */#if (!defined(_POSIX_C_SOURCE) || defined(_DARWIN_C_SOURCE))#define SIGIO 23 /* input/output possible signal */#endif#define SIGXCPU 24 /* exceeded CPU time limit */#define SIGXFSZ 25 /* exceeded file size limit */#define SIGVTALRM 26 /* virtual time alarm */#define SIGPROF 27 /* profiling time alarm */#if (!defined(_POSIX_C_SOURCE) || defined(_DARWIN_C_SOURCE))#define SIGWINCH 28 /* window size changes */#define SIGINFO 29 /* information request */#endif#define SIGUSR1 30 /* user defined signal 1 */#define SIGUSR2 31 /* user defined signal 2 */ SIGTRAP 5 -&gt; trace trap (not reset when caught)根据苹果的文档： Similar to an Abnormal Exit, this exception is intended to give an attached debugger the chance to interrupt the process at a specific point in its execution. You can trigger this exception from your own code using the __builtin_trap() function. If no debugger is attached, the process is terminated and a crash report is generated. Lower-level libraries (e.g, libdispatch) will trap the process upon encountering a fatal error. Additional information about the error can be found in the Additional Diagnostic Information section of the crash report, or in the device’s console. 这种错误也是属于异常错误，不过常用于连接调试器进行调试。某系底层库在遇到遇到严重错误时也会抛出这个错误，例如libdispatch。回看这个崩溃的运行栈，位于最顶端的是__dispatch_queue_resume，也是属于libdispatch这个库，应该是某个地方使用GCD出错。 分析定位崩溃的最后一个函数是__dispatch_queue_resume，可能和dispatch_resume函数有一定的关系，项目中使用地方的印象中应该不多。全局搜索一把，有以下结果：en…….用的地方还是挺多的，那到底是哪一个函数呢？回看崩溃栈： 123456* 7 CoreFoundation 0x18154fbf4 __CFXNotificationPost + 376* 8 Foundation 0x1820566bc -[NSNotificationCenter postNotificationName:object:userInfo:] + 68* 9 UIKit 0x18771d9d8 -[UIApplication _sendWillEnterForegroundCallbacks] + 232* 10 UIKit 0x187758ebc -[UIApplication _handleApplicationActivationWithScene:transitionContext:completion:] + 2140* 11 UIKit 0x1877583ec -[UIApplication _handleApplicationLifecycleEventWithScene:transitionContext:completion:] + 452* 12 UIKit 0x187743ae8 ___70-[UIApplication scene:didUpdateWithDiff:transitionContext:completion:]_block_invoke + 152 这几个函数指明此时App刚进入前台，正在广播ApplicationWillEnterForeground通知，看刚才的搜索结果，可以确认出问题的代码应该在[LEColorPicker appDidEnterForeground:]方法上。 123- (void)appDidEnterForeground:(NSNotification *)notification &#123; dispatch_resume(taskQueue);&#125; dispatch_resume看看此函数注释确认下是参数出错还是用法出发，注释如下：留意圈注的地方，如果dispatch_object已经激活再次调用resume此函数会抛出异常，结束进程。若传入参数为nil，行为不定。结合代码： 123456789101112131415161718192021222324252627282930313233343536dispatch_resume(taskQueue);- (id)init &#123; self = [super init]; if (self) &#123; // Create queue and set working flag initial state taskQueue = dispatch_queue_create(&quot;LEColorPickerQueue&quot;, DISPATCH_QUEUE_SERIAL); dispatch_set_target_queue(taskQueue, dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_LOW, 0)); _isActive = [UIApplication sharedApplication].applicationState == UIApplicationStateActive; // Add notifications for multitasking and background aware [self addNotificationObservers]; &#125; return self;&#125;- (void)addNotificationObservers &#123; // Add observers for notification to respond at app state changes. [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(appDidEnterBackground:) name:UIApplicationDidEnterBackgroundNotification object:nil]; [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(applicationWillResignActive:) name:UIApplicationWillResignActiveNotification object:nil]; [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(appDidEnterForeground:) name:UIApplicationWillEnterForegroundNotification object:nil];&#125;- (void)appDidEnterForeground:(NSNotification *)notification &#123; dispatch_resume(taskQueue);&#125; taskQueue成员变量在实例初始化时就被赋值且没有地方再设置为nil。难道是appDidEnterForeground:回调了两次，导致dispatch_resume(taskQueue);被调用了两次？ 12* 2 CoreFoundation 0x18160e22c ___CFNOTIFICATIONCENTER_IS_CALLING_OUT_TO_AN_OBSERVER__ + 20* 3 CoreFoundation 0x18160e22c ___CFNOTIFICATIONCENTER_IS_CALLING_OUT_TO_AN_OBSERVER__ + 20 崩溃栈的两个连续函数调用证明了appDidEnterForeground:回调了两次。 真相？？如果是addNotificationObservers被调用了两次，applicationWillResignActive:和appDidEnterForeground:都会被调用两次，dispatch_suspend和dispatch_resume的调用次数应该是匹配的，不会出现dispatch_resume次数大于dispatch_suspend的情况。难道是NSNotifictaion的Bug？搜索了CoreFoundation的源码也没有发现__CFXRegistrationPost相关的类。en………… 临时的解决方法…..1234567891011- (void)applicationWillResignActive:(NSNotification *)notification &#123; dispatch_suspend(taskQueue); _taskQueueSuspended = YES;&#125;- (void)appDidEnterForeground:(NSNotification *)notification &#123; if (_taskQueueSuspended) &#123; dispatch_resume(taskQueue); _taskQueueSuspended = NO; &#125;&#125; 打个标记，仅在标记开启时才调用dispatch_resume😂。 几个版本之后的结果此崩溃没有再出现过，但是根本原因还是没能找到……","categories":[{"name":"踩坑记录","slug":"踩坑记录","permalink":"http://yoursite.com/categories/踩坑记录/"},{"name":"崩溃定位及预防","slug":"踩坑记录/崩溃定位及预防","permalink":"http://yoursite.com/categories/踩坑记录/崩溃定位及预防/"}],"tags":[{"name":"踩坑记录","slug":"踩坑记录","permalink":"http://yoursite.com/tags/踩坑记录/"},{"name":"崩溃分析","slug":"崩溃分析","permalink":"http://yoursite.com/tags/崩溃分析/"}]},{"title":"iOS崩溃crash收集及分析","slug":"iOSCrashAnalyze","date":"2017-12-06T10:44:48.000Z","updated":"2017-12-07T10:51:00.633Z","comments":true,"path":"2017/12/06/iOSCrashAnalyze/","link":"","permalink":"http://yoursite.com/2017/12/06/iOSCrashAnalyze/","excerpt":"","text":"前言崩溃的出现意味着代码出现了问题，通常的解决路径是根据测试/用户/日志文件的行为描述，试图重现崩溃，定位到具体的代码位置，分析出现的原因，找到根治的办法，最后验证解决方案以确认崩溃被修复。那么我们该如何去搜集、分析、解决崩溃呢，请看下文。 如何收集崩溃信息？官方渠道XCode Organizer在Xcode-&gt;Window-&gt;Organizer选择已上架的App看以查看到每个版本中App的崩溃情况，如下图：优点： 自动符号化崩溃栈，甚至可以直接打开项目，跳转到相关文件代码 缺点： 只有崩溃数量及不同机型/系统下的占比，没有崩溃率。 只有崩溃栈信息，没有当时用户的操作记录，对于像上图中的崩溃，仅有崩溃栈信息，很难下手处理。 第三方服务：听云/Bugly/友盟听云听云收集的崩溃信息如下：听云记录的信息比较全面，包含崩溃率统计、崩溃栈、崩溃轨迹。 BuglyBugly收集的信息如下：Bugly收集到的信息包含崩溃率统计、崩溃栈，可以关联崩溃时的记录的日志。在日志中记录VC的打开记录，实现类似于听云的崩溃轨迹记录。 友盟友盟收集的信息如下：友盟收集到的信息包含崩溃率统计、崩溃栈。 小结优点： 除了崩溃时的运行栈外，还可以附带当时用户的使用轨迹！这非常有利于我们重建当时的崩溃场景！（友盟除外） 缺点： 需要自行上传DSYM文件。 对App有一定的入侵，可以抓取到App行为信息。 DIY自行构建使用如KSCrash或干脆自己写一个崩溃监测库，实现类似于上述第三方服务的功能。优点当然是可以实现任意想要的功能，但是开发成本比较大。 如何符号化崩溃信息？1234567891011120 CoreFoundation 0x0000000183491d1c &lt;redacted&gt; + 1481 libobjc.A.dylib 0x00000001826e0528 objc_exception_throw + 562 CoreFoundation 0x0000000183491c4c &lt;redacted&gt; + 03 YouAppsBinary 0x100817c80 YouAppsBinary + 84860164 libsystem_platform.dylib 0x00000001830b7b34 _sigtramp + 365 MediaToolbox 0x0000000187982300 FigPhotoJPEGShouldUseHardwareDecode + 766 ImageIO 0x00000001853e87ec &lt;redacted&gt; + 1887 ImageIO 0x00000001853e9180 &lt;redacted&gt; + 3128 ImageIO 0x00000001855447b0 &lt;redacted&gt; + 809 ImageIO 0x0000000185542d8c &lt;redacted&gt; + 10810 ImageIO 0x00000001853cac88 &lt;redacted&gt; + 31211 ImageIO 0x00000001853c8554 &lt;redacted&gt; + 428 在没有符号化崩溃信息之前，我们只能看到包含镜像名+函数内存地址的崩溃栈，没法得知具体的崩溃函数及行号，这时就需要使用DSYM文件对崩溃信息进行符号化。 DSYM文件XCode编译项目之后，会在yourApp.app同步目录下生成一个yourApp.app.dsym的bundle，里面包含了16进制函数地址映射到源文件函数行号的中转文件。有了这个文件，就可以将内存地址转换为崩溃发生时的源文件及行号。每个版本的app/dsym都有唯一匹配的UUID，只有当两者UUID唯一匹配时，16进制符号化出来的信息才是正确的。app/dysm的UUID可以使用以下命令查看。 12dwarfdump --uuid /xx/xx.appdwarfdump --uuid /xx/xx.app.dsym 如何符号化xcode的organizer的可以自动符号化它所及收集到的崩溃信息。将匹配的dsym文件上传到听云/Bugly，也可以得到符号化的崩溃信息。若想自己查看也可以通过以下命令查看: 1xcrun atos -arch arm64 -o /xxxx/xxx.app.dsym 函数地址 如何分析崩溃信息？这里有一篇不错的崩溃分析文章，可以详细参考下。 常见的崩溃原因及解决方案集合类插入nil/越界访问这些类型崩溃崩溃栈都有很明显的特征，栈顶附近通常带有_objc_exception_throw调用，为App没有处理相关异常，App最终崩溃。像听云/Bugly等第三发服务，会将异常信息打印出来，方便定位。如下： 121、[NSPlaceholderString initWithFormat:locale:arguments:]: nil argument 2、setObjectForKey: object cannot be nil 解决办法： 追踪异常数据的来源，从源头上堵住异常数据。避免一处加了保护，导致脏数据流向别的流程，出发其他异常。 给所有集合类加上nil/越界访问保护，例如定义一些Category或替换一些不安全的方法。但要加上合适的断言/上报机制，尽快发现和处理这种异常情况。 unrecognized selector出现这种崩溃的原因通常为： 调用了高版本系统API 业务处理逻辑未考虑到某些异常情况，强转类型出错。这种问题很容易出现在含复杂状态管理的业务里 解决办法： 对于第一种情况，在使用不熟悉的API时，要留意一下可用的系统版本。此外在使用高系统版本的API时，XCode 9会出现警告，多留意一下即可。 取决于细不细心啰。 或者利用objc的消息转发机制，动态添加未知的selector的实现。但是这种方法有缺陷，在未知selector的转发流程中，我们拿到的只有selector，没有方法实现，因此我们不知道此selctor的返回值类型是什么。假设我们默认返回nil，若此selector原本返回的是对象，则有可能不崩溃。若此selector原本返回的是block/结构体，就会导致别的崩溃。 Application received signal 11/SIGSEGV出现了非法内存访问，例如 123456Application received signal 11 1. libobjc.A.dylib 0x1800b9b88 _objc_msgSend + 8 2. CoreFoundation 0x180a3f1b8 ___rehashd + 152 3. CoreFoundation 0x180928468 -[__NSDictionaryM setObject:forKey:] + 688 4. app. 0x10027ba04 [BaseDataModel initialize] (BaseDataModel.m:31) 出现这种崩溃的原因通常为： 使用了assign作为修饰符，在对象释放之后，仍然进行访问。 不同线程同时操作可变集合类/赋值同一个成员变量。 解决办法： 在合适的时候置为nil或改为用weak修饰。某些系统API，如CBCentralManager的delegate属性在iOS 11上声明为weak，然而在旧版本上缺声明为assign，所以遇到系统给的delegate，在dealloc时，最好设置为nil。 涉及线程管理，后续再做讨论。 参考文章 iOS崩溃crash大解析 如何定位Obj-C野指针随机Crash系列 小萝莉说Crash系列","categories":[{"name":"崩溃定位及预防","slug":"崩溃定位及预防","permalink":"http://yoursite.com/categories/崩溃定位及预防/"}],"tags":[{"name":"崩溃分析","slug":"崩溃分析","permalink":"http://yoursite.com/tags/崩溃分析/"},{"name":"崩溃定位","slug":"崩溃定位","permalink":"http://yoursite.com/tags/崩溃定位/"}]}]}