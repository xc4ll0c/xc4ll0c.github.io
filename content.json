{"meta":{"title":"xc4ll0c","subtitle":"biu biu biu","description":null,"author":"wenZheng zhang","url":"http://yoursite.com"},"pages":[{"title":"about","date":"2017-12-08T03:02:16.000Z","updated":"2017-12-08T03:03:44.161Z","comments":true,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":""},{"title":"categories","date":"2017-12-08T03:02:05.000Z","updated":"2017-12-08T03:03:05.158Z","comments":true,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2017-12-08T03:01:45.000Z","updated":"2017-12-08T03:03:33.430Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"iOS崩溃crash收集及分析","slug":"iOSCrashAnalyze","date":"2017-12-06T10:44:48.000Z","updated":"2017-12-07T10:51:00.633Z","comments":true,"path":"2017/12/06/iOSCrashAnalyze/","link":"","permalink":"http://yoursite.com/2017/12/06/iOSCrashAnalyze/","excerpt":"","text":"前言崩溃的出现意味着代码出现了问题，通常的解决路径是根据测试/用户/日志文件的行为描述，试图重现崩溃，定位到具体的代码位置，分析出现的原因，找到根治的办法，最后验证解决方案以确认崩溃被修复。那么我们该如何去搜集、分析、解决崩溃呢，请看下文。 如何收集崩溃信息？官方渠道XCode Organizer在Xcode-&gt;Window-&gt;Organizer选择已上架的App看以查看到每个版本中App的崩溃情况，如下图：优点： 自动符号化崩溃栈，甚至可以直接打开项目，跳转到相关文件代码 缺点： 只有崩溃数量及不同机型/系统下的占比，没有崩溃率。 只有崩溃栈信息，没有当时用户的操作记录，对于像上图中的崩溃，仅有崩溃栈信息，很难下手处理。 第三方服务：听云/Bugly/友盟听云听云收集的崩溃信息如下：听云记录的信息比较全面，包含崩溃率统计、崩溃栈、崩溃轨迹。 BuglyBugly收集的信息如下：Bugly收集到的信息包含崩溃率统计、崩溃栈，可以关联崩溃时的记录的日志。在日志中记录VC的打开记录，实现类似于听云的崩溃轨迹记录。 友盟友盟收集的信息如下：友盟收集到的信息包含崩溃率统计、崩溃栈。 小结优点： 除了崩溃时的运行栈外，还可以附带当时用户的使用轨迹！这非常有利于我们重建当时的崩溃场景！（友盟除外） 缺点： 需要自行上传DSYM文件。 对App有一定的入侵，可以抓取到App行为信息。 DIY自行构建使用如KSCrash或干脆自己写一个崩溃监测库，实现类似于上述第三方服务的功能。优点当然是可以实现任意想要的功能，但是开发成本比较大。 如何符号化崩溃信息？1234567891011120 CoreFoundation 0x0000000183491d1c &lt;redacted&gt; + 1481 libobjc.A.dylib 0x00000001826e0528 objc_exception_throw + 562 CoreFoundation 0x0000000183491c4c &lt;redacted&gt; + 03 YouAppsBinary 0x100817c80 YouAppsBinary + 84860164 libsystem_platform.dylib 0x00000001830b7b34 _sigtramp + 365 MediaToolbox 0x0000000187982300 FigPhotoJPEGShouldUseHardwareDecode + 766 ImageIO 0x00000001853e87ec &lt;redacted&gt; + 1887 ImageIO 0x00000001853e9180 &lt;redacted&gt; + 3128 ImageIO 0x00000001855447b0 &lt;redacted&gt; + 809 ImageIO 0x0000000185542d8c &lt;redacted&gt; + 10810 ImageIO 0x00000001853cac88 &lt;redacted&gt; + 31211 ImageIO 0x00000001853c8554 &lt;redacted&gt; + 428 在没有符号化崩溃信息之前，我们只能看到包含镜像名+函数内存地址的崩溃栈，没法得知具体的崩溃函数及行号，这时就需要使用DSYM文件对崩溃信息进行符号化。 DSYM文件XCode编译项目之后，会在yourApp.app同步目录下生成一个yourApp.app.dsym的bundle，里面包含了16进制函数地址映射到源文件函数行号的中转文件。有了这个文件，就可以将内存地址转换为崩溃发生时的源文件及行号。每个版本的app/dsym都有唯一匹配的UUID，只有当两者UUID唯一匹配时，16进制符号化出来的信息才是正确的。app/dysm的UUID可以使用以下命令查看。 12dwarfdump --uuid /xx/xx.appdwarfdump --uuid /xx/xx.app.dsym 如何符号化xcode的organizer的可以自动符号化它所及收集到的崩溃信息。将匹配的dsym文件上传到听云/Bugly，也可以得到符号化的崩溃信息。若想自己查看也可以通过以下命令查看: 1xcrun atos -arch arm64 -o /xxxx/xxx.app.dsym 函数地址 如何分析崩溃信息？这里有一篇不错的崩溃分析文章，可以详细参考下。 常见的崩溃原因及解决方案集合类插入nil/越界访问这些类型崩溃崩溃栈都有很明显的特征，栈顶附近通常带有_objc_exception_throw调用，为App没有处理相关异常，App最终崩溃。像听云/Bugly等第三发服务，会将异常信息打印出来，方便定位。如下： 121、[NSPlaceholderString initWithFormat:locale:arguments:]: nil argument 2、setObjectForKey: object cannot be nil 解决办法： 追踪异常数据的来源，从源头上堵住异常数据。避免一处加了保护，导致脏数据流向别的流程，出发其他异常。 给所有集合类加上nil/越界访问保护，例如定义一些Category或替换一些不安全的方法。但要加上合适的断言/上报机制，尽快发现和处理这种异常情况。 unrecognized selector出现这种崩溃的原因通常为： 调用了高版本系统API 业务处理逻辑未考虑到某些异常情况，强转类型出错。这种问题很容易出现在含复杂状态管理的业务里 解决办法： 对于第一种情况，在使用不熟悉的API时，要留意一下可用的系统版本。此外在使用高系统版本的API时，XCode 9会出现警告，多留意一下即可。 取决于细不细心啰。 或者利用objc的消息转发机制，动态添加未知的selector的实现。但是这种方法有缺陷，在未知selector的转发流程中，我们拿到的只有selector，没有方法实现，因此我们不知道此selctor的返回值类型是什么。假设我们默认返回nil，若此selector原本返回的是对象，则有可能不崩溃。若此selector原本返回的是block/结构体，就会导致别的崩溃。 Application received signal 11/SIGSEGV出现了非法内存访问，例如 123456Application received signal 11 1. libobjc.A.dylib 0x1800b9b88 _objc_msgSend + 8 2. CoreFoundation 0x180a3f1b8 ___rehashd + 152 3. CoreFoundation 0x180928468 -[__NSDictionaryM setObject:forKey:] + 688 4. app. 0x10027ba04 [BaseDataModel initialize] (BaseDataModel.m:31) 出现这种崩溃的原因通常为： 使用了assign作为修饰符，在对象释放之后，仍然进行访问。 不同线程同时操作可变集合类/赋值同一个成员变量。 解决办法： 在合适的时候置为nil或改为用weak修饰。某些系统API，如CBCentralManager的delegate属性在iOS 11上声明为weak，然而在旧版本上缺声明为assign，所以遇到系统给的delegate，在dealloc时，最好设置为nil。 涉及线程管理，后续再做讨论。 参考文章 iOS崩溃crash大解析 如何定位Obj-C野指针随机Crash系列 小萝莉说Crash系列","categories":[{"name":"崩溃定位及预防","slug":"崩溃定位及预防","permalink":"http://yoursite.com/categories/崩溃定位及预防/"}],"tags":[{"name":"崩溃定位","slug":"崩溃定位","permalink":"http://yoursite.com/tags/崩溃定位/"},{"name":"崩溃分析","slug":"崩溃分析","permalink":"http://yoursite.com/tags/崩溃分析/"}]}]}