{"meta":{"title":"xc4ll0c","subtitle":"biu biu biu","description":null,"author":"wenZheng zhang","url":"http://yoursite.com"},"pages":[{"title":"about","date":"2017-12-08T03:02:16.000Z","updated":"2017-12-08T03:03:44.161Z","comments":true,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":""},{"title":"categories","date":"2017-12-08T03:02:05.000Z","updated":"2017-12-08T03:03:05.158Z","comments":true,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2017-12-08T03:01:45.000Z","updated":"2017-12-08T03:03:33.430Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"探索：阻止Unrecognized Selector Crash崩溃的出现","slug":"AnExperimentOnPreventingUnrecognizedSelectorCrash","date":"2017-12-13T06:24:15.000Z","updated":"2017-12-15T07:49:04.125Z","comments":true,"path":"2017/12/13/AnExperimentOnPreventingUnrecognizedSelectorCrash/","link":"","permalink":"http://yoursite.com/2017/12/13/AnExperimentOnPreventingUnrecognizedSelectorCrash/","excerpt":"前言向对象发送其不能响应的selector时，会触发unrecognized selector sent to instance xxx的异常，没有捕捉到异常时，App最终会崩溃。这篇文章会尝试利用objective-c runtime提供的Dynamic Method Resolution和Message Forwarding机制阻止Unrecognized Selector Crash崩溃的出现。Demo地址","text":"前言向对象发送其不能响应的selector时，会触发unrecognized selector sent to instance xxx的异常，没有捕捉到异常时，App最终会崩溃。这篇文章会尝试利用objective-c runtime提供的Dynamic Method Resolution和Message Forwarding机制阻止Unrecognized Selector Crash崩溃的出现。Demo地址 Dynamic Method Resolution &amp; Message ForwardingDynamic Method Resolution向objc类的实例发送的消息时，objcRuntime用消息的selector的在此类查询相应的方法实现IMP，若类中查询不到则转向父类查询，若任然查询不到selector对应的IMP。则进入Dynamic Method Resolution流程，runtime提供以下两个方法，分别用于动态添加类方法和成员方法。 12+ (BOOL)resolveClassMethod:(SEL)sel;+ (BOOL)resolveInstanceMethod:(SEL)sel; 例如TestObject声明了aVoidMethod方法，但是没有提供实现，在运行时可以利用Dynamic Method Resolution动态添加aVoidMethod方法的实现，代码如下： 1234567891011121314151617// 动态的实现void _TestObject_dynamic_imp_(id self, SEL sel) &#123;&#125;@interface TestObject : NSObject- (void)aVoidMethod;@end@implementation TestObject+ (BOOL)resolveInstanceMethod:(SEL)sel &#123; if (sel == @selector(aVoidMethod)) &#123; class_addMethod([self class], sel, (IMP)_TestObject_dynamic_imp_, \"v@:\"); return YES; &#125; return [super resolveInstanceMethod:sel];&#125;@end objc的类/实例方法实际就是一个C函数，所谓的IMP实际上就是函数指针，这个函数至少接受两个参数一个是self(接收消息的实例/类)，一个是_cmd(selector)。通过class_addMethod可以动态的为一个类添加selector及其关联的IMP。“v@:”字符串描述的是IMP的返回值类型、参数数量及类型。第一个字符表示返回值类型（”v”=void）,第二和第三个为固定参数，分别表示self和_cmd。“v@:”表示的含义是返回为void且不接受参数的函数，其他参数类型编码可以参考此文章。 关于Dynamic Method Resolution和Message Forwarding的触发顺序，runtime的文档： Forwarding methods (as described in Message Forwarding) and dynamic method resolution are, largely, orthogonal. A class has the opportunity to dynamically resolve a method before the forwarding mechanism kicks in. If respondsToSelector: or instancesRespondToSelector: is invoked, the dynamic method resolver is given the opportunity to provide an IMP for the selector first. If you implement resolveInstanceMethod: but want particular selectors to actually be forwarded via the forwarding mechanism, you return NO for those selectors. 指出Dynamic Method Resolution发生在Message Forwarding之前，且respondsToSelector: 或 instancesRespondToSelector: 也会触发Dynamic Method Resolution流程。 Message Forwarding当Dynamic Method Resolution中没有提供selector的IMP，则会进入到Message Forwarding（消息转发）的流程。runtime先调用forwardingTargetForSelector:，要求提供消息转发的对象，若返回非nil对象，则消息转发至该对象。若返回nil，则转向到代价更高，构造NSInvocation的流程。runtime调用methodSignatureForSelector:提供构造NSInvocation所需的返回值类型、参数数量、参数类型等信息，若在此方法返回nil，则会触发unrecognized selector异常，若返回NSMethodSignature，runtime依据此信息构造NSInvocation实例，调用forwardInvocation:方法，invocation的返回值会返回给消息的发送者。 利用消息转发可以转发unrecognized selector至不同消息实现者，借用它们的IMP，实现类似于多继承的功能，以下为消息转发的demo代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667@interface A : NSObject- (NSString *)aMethod;@end@interface B : NSObject- (NSString *)bMethod;@end@interface AB : NSObject- (NSString *)aMethod;- (NSString *)bMethod;@end@implementation A- (NSString *)aMethod &#123; return @\"From Class A\";&#125;@end@implementation B- (NSString *)bMethod &#123; return @\"From Class B\";&#125;@end@interface AB ()@property (nonatomic, strong) A *a;@property (nonatomic, strong) B *b;@end@implementation AB- (instancetype)init &#123; self = [super init]; if (self) &#123; _a = [[A alloc] init]; _b = [[B alloc] init]; &#125; return self;&#125;- (id)forwardingTargetForSelector:(SEL)aSelector &#123; // aMethod利用forwardingTargetForSelector:转发 if ([self.a respondsToSelector:aSelector]) &#123; return self.a; &#125; else &#123; return [super forwardingTargetForSelector:aSelector]; &#125;&#125;- (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector &#123; // bMethod利用forwardInvocation:转发 NSMethodSignature *sig = [self.b methodSignatureForSelector:aSelector]; if (!sig) &#123; sig = [super methodSignatureForSelector:aSelector]; &#125; return sig;&#125;- (void)forwardInvocation:(NSInvocation *)anInvocation &#123; // bMethod利用forwardInvocation:转发 if ([self.b respondsToSelector:[anInvocation selector]]) &#123; [anInvocation invokeWithTarget:self.b]; &#125; else &#123; [super forwardInvocation:anInvocation]; &#125;&#125; A和B分别实现了aMethod、bMethod的类，AB声明aMethod和bMethod，且利用消息转发机制转发消息到A和B对象。测试代码如下： 12345678910- (void)messageForwardingDemo &#123; AB *ab = [[AB alloc] init]; NSLog(@\"AB responds to aMethod ? %@\", [ab respondsToSelector:@selector(aMethod)] ? @\"YES\" : @\"NO\"); NSLog(@\"AB responds to bMethod ? %@\", [ab respondsToSelector:@selector(bMethod)] ? @\"YES\" : @\"NO\"); NSLog(@\"result of sending aMethod to AB: %@\", [ab aMethod]); NSLog(@\"result of sending bMethod to AB: %@\", [ab bMethod]); NSLog(@\"mark end\");&#125; 创建AB类的实例，使用respondsToSelector:测试实例是否响应方法，然后调用方法并输出结果。结果如下： 123452017-12-14 11:11:56.039216+0800 APP[84699:4307744] AB responds to aMethod ? NO2017-12-14 11:11:56.039400+0800 APP[84699:4307744] AB responds to bMethod ? NO2017-12-14 11:11:56.039558+0800 APP[84699:4307744] result of sending aMethod to AB: From Class A2017-12-14 11:11:56.039706+0800 APP[84699:4307744] result of sending bMethod to AB: From Class B2017-12-14 11:11:56.039817+0800 APP[84699:4307744] mark end respondsToSelector:测试均失败，说明实现消息转发流程不会影响respondsToSelector:测试对象是否响应某个方法的结果（respondsToSelector:依赖于selector是否有相关的IMP），实际调用没有任何问题，消息都被成功转发。 整体流程objc对象响应消息的综合流程如下图： 阻止Unrecognized Selector Crash思路objc的runtime给了我们三次机会提供unrecognized selector的实现或转发给有能力做响应的对象。只要在三个地方中一个做了合适的处理，应该可以避免unrecognized selector崩溃。本文的实现策略是替换NSObject中相关的实现，以便对所有类生效。如果只想对指定类生效，可以改为替换指定类的实现。 疑点1、unrecognized selector仅有selector信息，原方法的返回值类型、参数数量和类型均不知道，那么动态提供的IMP返回值和参数如何确定?方法的参数类型和数量由Type Encoding字符串如”V@:”决定，第四个字符开始描述参数类型，那么可以尝试不提供其他参数编码，那么不管selctor对应多少参数，实际调用时都应该不会进行参数解析，避免解析出错。至于返回值可以给个nil试一下。 2、如果避免干扰到其他利用消息转发流程实现的功能？。2.1. 利用resolveInstanceMethod:的实现：检查当前类有无重写resolveInstanceMethod:，若有重写则不执行保护流程，若没有则开启保护流程。如果该类没有重写resolveInstanceMethod:但是利用了forwardingTargetForSelector:或forwardInvocation:进行转发呢？可以在resolveInstanceMethod:中调用forwardingTargetForSelector:以及methodSignatureForSelector:有无返回值来判定该类有没有自定义转发流程。 2.2. 利用forwardingTargetForSelector:的实现：检查有无重写forwardingTargetForSelector:，若有重写则不执行保护流程，若没有则开启保护流程。调用methodSignatureForSelector:，看其有无返回值来判断有没有自定转发流程。 2.3. 利用forwardInvocation:的实现：只需检查当前类有无重写methodSignatureForSelector:即可。 测试用例测试类定义如下： 123456789101112131415161718struct SimpleStruct &#123; NSInteger i;&#125;;typedef struct SimpleStruct SimpleStruct;#pragma mark - TestObject@interface TestObject : NSObject- (void)voidMethod;- (id)methodReturnsAnObject;- (NSInteger)methodReturnsABasicValue;- (SimpleStruct)methodReturnsAStruct;- (id)methodReturnsAnObjectWithP1:(id)p1 rect:(CGRect)rect;- (CGRect)methodReturnsACGRect;@end@implementation TestObject@end TestObject类声明六个方法，但均为提供实现。若方案有效，则向TestObject实例发送这六个消息均不会发生崩溃，也可以获取到返回值。具体测试代码如下: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071// 测试无参数无返回值的情况- (void)testThatItCanProtectVoidMethod &#123; TestObject *tObject = [[TestObject alloc] init]; @try &#123; [tObject voidMethod]; &#125; @catch (NSException *exception) &#123; // 不能抛出异常 XCTAssertTrue(false); &#125;&#125;// 测试无参数但返回值一个对象的情况- (void)testThatItCanProtectMethodReturnsAnObject &#123; TestObject *tObject = [[TestObject alloc] init]; @try &#123; id object = [tObject methodReturnsAnObject]; NSLog(@\"%@\", object); &#125; @catch (NSException *exception) &#123; // 不能抛出异常 XCTAssertTrue(false); &#125;&#125;// 测试无参数但返回值一个基本数据类型的情况- (void)testThatItCanMethodReturnsABasicValue &#123; TestObject *tObject = [[TestObject alloc] init]; @try &#123; NSInteger i = [tObject methodReturnsABasicValue]; NSLog(@\"%@\", @(i)); &#125; @catch (NSException *exception) &#123; // 不能抛出异常 XCTAssertTrue(false); &#125;&#125;// 测试无参数但返回值一个含单个值的结构体的情况- (void)testThatItCanProtectMethodReturnsAStruct &#123; TestObject *tObject = [[TestObject alloc] init]; @try &#123; SimpleStruct aStruct = [tObject methodReturnsAStruct]; NSLog(@\"%@\", @(aStruct.i)); &#125; @catch (NSException *exception) &#123; // 不能抛出异常 XCTAssertTrue(false); &#125;&#125;// 测试有参数有返回值的情况- (void)testThatItCanProtectMethodReturnsAnObjectWithP1 &#123; TestObject *tObject = [[TestObject alloc] init]; @try &#123; id object = [tObject methodReturnsAnObjectWithP1:[[NSObject alloc] init] rect:CGRectMake(10, 20, 100, 200)]; NSLog(@\"%@\", object); &#125; @catch (NSException *exception) &#123; // 不能抛出异常 XCTAssertTrue(false); &#125;&#125;// 测试无参数但返回CGRect的情况- (void)testThatItCanProtectMethodReturnsACGRect &#123; TestObject *tObject = [[TestObject alloc] init]; @try &#123; CGRect aStruct = [tObject methodReturnsACGRect]; NSLog(@\"%@\", @(aStruct.origin.x)); &#125; @catch (NSException *exception) &#123; // 不能抛出异常 XCTAssertTrue(false); &#125;&#125; 利用unrecognized selector会抛出异常的特点来判定测试是否成功。 实现1:利用resolveInstanceMethod：动态提供方法的IMP实现代码如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293id _trim_unrecognized_default_imp_(id self, SEL sel) &#123; return nil;&#125;#pragma mark - TypeResolveInstanceMethod@implementation NSObject (TypeResolveInstanceMethod)+ (void)TRIM_startUnrecognizedSelectorProtection &#123; [self TRIM_exchangeResolveInstanceMethodMethod];&#125;+ (void)TRIM_stopUnrecognizedSelectorProtection &#123; [self TRIM_exchangeResolveInstanceMethodMethod];&#125;+ (void)TRIM_exchangeResolveInstanceMethodMethod &#123; [[self class] ra_swizzleClassMethodWithOriginalSEL:@selector(resolveInstanceMethod:) swizzledSEL:@selector(TRIM_resolveInstanceMethod:)];&#125;+ (BOOL)TRIM_resolveInstanceMethod:(SEL)sel &#123; // methodSignatureForSelector: 在找不到方法现实时会调用resolveInstanceMethod：获取方法实现 // 所以在resolveInstanceMethod：直接调用methodSignatureForSelector：会造成死循环调用 // 是否进入了循环调用，返回NO，破除循环调用 if ([self TRIM_isInRecusiveCallForSelector:sel]) &#123; return NO; &#125; // 先判断类是否已经实现了resolveInstanceMethod转发流程 BOOL isResolved = [self TRIM_resolveInstanceMethod:sel]; // 若子类已经重写，避免干扰子类的流程，直接返回NSObject的实现 if ([[self class] ra_isMethodOveridedNSObjectImplementationForSelector:@selector(resolveInstanceMethod:) isClassMethod:YES]) &#123; return isResolved; &#125; // 判断类是否通过forwardingTargetForSelector:实现了转发流程 if (!isResolved) &#123; id forwardingTarget = [self forwardingTargetForSelector:sel]; isResolved = forwardingTarget != nil; &#125; // 判断类是否通过forwardInvocation:实现了转发流程 if (!isResolved) &#123; [self TRIM_markRecusiveCallStartForSelector:sel]; NSMethodSignature *sig = [self methodSignatureForSelector:sel]; [self TRIM_unmarkRecusiveCallStartForSelector:sel]; isResolved = sig != nil; &#125; // 此类未实现任何转发流程，则开启防护措施 if (!isResolved) &#123; // 动态添加一个实现 class_addMethod([self class], sel, (IMP)_trim_unrecognized_default_imp_, \"@@:\"); return YES; &#125; return isResolved;&#125;+ (NSCache *)TRIM_SharedCache &#123; static __strong NSCache *aCache = nil; static dispatch_once_t onceToken; dispatch_once(&amp;onceToken, ^&#123; aCache = [[NSCache alloc] init]; &#125;); return aCache;&#125;#pragma mark - 信息标记+ (CPThreadSafeCounter *)TRIM_ClassSharedcounter &#123; NSCache *aCache = [self TRIM_SharedCache]; NSString *key = NSStringFromClass(self); CPThreadSafeCounter *counter = [aCache objectForKey:key]; if (!counter) &#123; counter = [[CPThreadSafeCounter alloc] init]; [aCache setObject:counter forKey:key]; &#125; return counter;&#125;+ (BOOL)TRIM_isInRecusiveCallForSelector:(SEL)aSelector &#123; CPThreadSafeCounter *counter = [self TRIM_ClassSharedcounter]; return ![counter isZeroCountForObject:NSStringFromSelector(aSelector)];&#125;+ (void)TRIM_markRecusiveCallStartForSelector:(SEL)aSelector &#123; CPThreadSafeCounter *counter = [self TRIM_ClassSharedcounter]; [counter addCountForObject:NSStringFromSelector(aSelector)];&#125;+ (void)TRIM_unmarkRecusiveCallStartForSelector:(SEL)aSelector &#123; CPThreadSafeCounter *counter = [self TRIM_ClassSharedcounter]; [counter decreaseCountForObject:NSStringFromSelector(aSelector)];&#125; 实际实现的代码比预想中的要长，因为要避免一些坑。 遇到的坑调用methodSignatureForSelector:时，若selector下没有相关的sig，会触发resolveInstanceMethod:所以会出现死循环调用，为了打破循环，在调用resolveInstanceMethod:中调用methodSignatureForSelector:之前，通过TRIM_markRecusiveCallStartForSelector:为此selector打下标记，表明即将进入循环调用，在进入resolveInstanceMethod:方法是，检查selector有打上进入循环的标记，若已经进入，则直接返回NO。 测试结果失败的理由为BAD_ACCESS，失败的测试用例如下： 1234567891011// 测试无参数但返回CGRect的情况- (void)testThatItCanProtectMethodReturnsACGRect &#123; TestObject *tObject = [[TestObject alloc] init]; @try &#123; CGRect aStruct = [tObject methodReturnsACGRect]; NSLog(@\"%@\", @(aStruct.origin.x)); &#125; @catch (NSException *exception) &#123; // 不能抛出异常 XCTAssertTrue(false); &#125;&#125; 为什么会出现BAD_ACCESS？查看函数的调用过程，实现1的确给methodReturnsACGRect selector提供了默认实现，但是在调用这个实现时就出现了内存访问错误。这个仓库下有objc runtime的可编译源码，拿来一探究竟吧。结果如下图:在进入默认实现_trim_unrecognized_default_imp_之前，对某个对象进行retain(ARC下编译器自动补充的内存管理代码)操作时，发生了访问异常。看看obj的情况：无法访问，那objc_storeStrong又做了些什么： 1234567891011voidobjc_storeStrong(id *location, id obj)&#123; id prev = *location; if (obj == prev) &#123; return; &#125; objc_retain(obj); *location = obj; objc_release(prev);&#125; 看代码应该是将obj赋值到一个变量上，结合上面的调用流程，这个变量会作为参数传给_trim_unrecognized_default_imp_，也就是self/sel出了问题。emmmm……..为什么这两个参数会出问题呢？依稀记得clang有个参数可以将objc的代码完整转码为c++实现，用于窥探objc/及编译器的秘密。命令如下： 1clang -rewrite-objc inputFile -o outputfile 处理后拿到的关键代码如下： 123456789101112131415161718192021222324extern \"C\" void * __cdecl memset(void *_Dst, int _Val, size_t _Size);namespace &#123;struct __Stret0 &#123; __Stret0(id receiver, SEL sel) &#123; unsigned size = sizeof(CGRect); if (size == 1 || size == 2 || size == 4 || size == 8) s = ((CGRect (*)(id, SEL))(void *)objc_msgSend)(receiver, sel); else if (receiver == 0) memset((void*)&amp;s, 0, sizeof(s)); else s = ((CGRect (*)(id, SEL))(void *)objc_msgSend_stret)(receiver, sel); &#125; CGRect s;&#125;;&#125;;int main(int argc, const char * argv[]) &#123; /* @autoreleasepool */ &#123; __AtAutoreleasePool __autoreleasepool; TestObject *testObject = ((TestObject *(*)(id, SEL))(void *)objc_msgSend)((id)((TestObject *(*)(id, SEL))(void *)objc_msgSend)((id)objc_getClass(\"TestObject\"), sel_registerName(\"alloc\")), sel_registerName(\"init\")); __Stret0((id)testObject, sel_registerName(\"methodReturnsACGRect\")).s; &#125; return 0;&#125; 我们知道objc的消息最终都会转为调用objc_msgSend函数，TestObject的alloc和init就是如此，但是调用methodReturnsACGRect方法时却发生了变化，编译器自动生成了__Stret0代码，内部更具CGRect的size决定调用objc_msgSend还是objc_msgSend_stret。objc_msgSend_stret的文档如下: Sends a message with a data-structure return value to an instance of a class. 当返回值为struct时，会转为调用objc_msgsend_stret做消息发送，那么objc_msgSend和objc_msgSend_stret在实现上有什么区别呢？根据文章objc explain: objc_msgSend_stret中的解释，在常规的函数调用中参数和返回值都可以保存在寄存器中，例如方法- (int)method:(id)arg;寄存器分配如下： 12345-(int) method:(id)arg; r3 = self r4 = _cmd, @selector(method:) r5 = arg (on exit) r3 = returned int 参数和返回值都可以保存在寄存器中，但是面对过大的struct返回值时，函数调用者得先申请栈空间，且将这个栈地址传入函数，作为struct返回值的写入地址。 123456-(struct st) method:(id)arg; r3 = &amp;struct_var (in caller's stack frame) r4 = self r5 = _cmd, @selector(method:) r6 = arg (on exit) return value written into struct_var 栈地址作为第一个参数，其他参数向后挪。oh！似乎找到了问题所在。文章Inspecting Obj-C parameters in gdb描述了x86_64下，寄存器和参数的关系如下： $rdi ➡ arg0 (通常为self，stret下为struct返回值写入地址)$rsi ➡ arg1 (通常为_cmd，stret下为self).$rdx ➡ arg2 (stret下为_cmd).$rcx ➡ arg3.$r8 ➡ arg4.$r9 ➡ arg5. _trim_unrecognized_default_imp_转为汇编代码(x86_64 AT&amp;T风格)后，如下: 1234567891011121314151617181920212223242526272829303132333435363738394041__trim_unrecognized_default_imp_: ## @_trim_unrecognized_default_imp_Lfunc_begin0: .loc 1 15 0 .cfi_startproc## BB#0: pushq %rbpLcfi0: .cfi_def_cfa_offset 16Lcfi1: .cfi_offset %rbp, -16 movq %rsp, %rbpLcfi2: .cfi_def_cfa_register %rbp subq $32, %rsp leaq -8(%rbp), %rax movq $0, -8(%rbp) movq %rdi, -24(%rbp) // 将第一个参数，应该为id self，存到临时变量 movq %rax, %rdi movq -24(%rbp), %rax // 将临时变量中的id self，存到寄存器rax movq %rsi, -32(%rbp) movq %rax, %rsi // 将rax的值也即是id self，作为_objc_storeStrong第二个参数 callq _objc_storeStrong leaq -8(%rbp), %rdi xorl %ecx, %ecx movl %ecx, %esi ##DEBUG_VALUE: _trim_unrecognized_default_imp_:self &lt;- [%RDI+0] movq -32(%rbp), %rax ## 8-byte Reload movq %rax, -16(%rbp)Ltmp0: .loc 1 17 1 prologue_end callq _objc_storeStrongLtmp1: .loc 1 0 1 is_stmt 0 xorl %ecx, %ecx movl %ecx, %eax .loc 1 17 1 addq $32, %rsp popq %rbp retqLtmp2:Lfunc_end0: objc_storeStrong的第二个参数为需要retain的对象，所以关注寄存器rsi的赋值情况，rsi被赋予上一个函数在rdi(第一个参数)下留下的值，看看从objc_msgSend_stret的汇编代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243libobjc.A.dylib`_objc_msgSend_stret_uncached: // rdi = stretAddres, rsi = arg1(self), rdx = args2(_cmd)-&gt; 0x100319550 &lt;+0&gt;: pushq %rbp 0x100319551 &lt;+1&gt;: movq %rsp, %rbp 0x100319554 &lt;+4&gt;: subq $0x88, %rsp 0x10031955b &lt;+11&gt;: movdqa %xmm0, -0x80(%rbp) 0x100319560 &lt;+16&gt;: pushq %rax 0x100319561 &lt;+17&gt;: movdqa %xmm1, -0x70(%rbp) 0x100319566 &lt;+22&gt;: pushq %rdi 0x100319567 &lt;+23&gt;: movdqa %xmm2, -0x60(%rbp) 0x10031956c &lt;+28&gt;: pushq %rsi 0x10031956d &lt;+29&gt;: movdqa %xmm3, -0x50(%rbp) 0x100319572 &lt;+34&gt;: pushq %rdx 0x100319573 &lt;+35&gt;: movdqa %xmm4, -0x40(%rbp) 0x100319578 &lt;+40&gt;: pushq %rcx 0x100319579 &lt;+41&gt;: movdqa %xmm5, -0x30(%rbp) 0x10031957e &lt;+46&gt;: pushq %r8 0x100319580 &lt;+48&gt;: movdqa %xmm6, -0x20(%rbp) 0x100319585 &lt;+53&gt;: pushq %r9 0x100319587 &lt;+55&gt;: movdqa %xmm7, -0x10(%rbp) 0x10031958c &lt;+60&gt;: movq %rsi, %rdi 0x10031958f &lt;+63&gt;: movq %rdx, %rsi 0x100319592 &lt;+66&gt;: movq %r10, %rdx // 调用_class_lookupMethodAndLoadCache3函数有对寄存器的值做调整，以避免其读出错误参数 0x100319595 &lt;+69&gt;: callq 0x100319990 ; ::_class_lookupMethodAndLoadCache3(id, SEL, Class) at objc-runtime-new.mm:4572 0x10031959a &lt;+74&gt;: movq %rax, %r11 // r11保存了_class_lookupMethodAndLoadCache3查询来的IMP(_trim_unrecognized_default_imp_) 0x10031959d &lt;+77&gt;: movdqa -0x80(%rbp), %xmm0 // 恢复调用_class_lookupMethodAndLoadCache3函数前的寄存器值 0x1003195a2 &lt;+82&gt;: popq %r9 0x1003195a4 &lt;+84&gt;: movdqa -0x70(%rbp), %xmm1 0x1003195a9 &lt;+89&gt;: popq %r8 0x1003195ab &lt;+91&gt;: movdqa -0x60(%rbp), %xmm2 0x1003195b0 &lt;+96&gt;: popq %rcx 0x1003195b1 &lt;+97&gt;: movdqa -0x50(%rbp), %xmm3 0x1003195b6 &lt;+102&gt;: popq %rdx 0x1003195b7 &lt;+103&gt;: movdqa -0x40(%rbp), %xmm4 0x1003195bc &lt;+108&gt;: popq %rsi 0x1003195bd &lt;+109&gt;: movdqa -0x30(%rbp), %xmm5 0x1003195c2 &lt;+114&gt;: popq %rdi 0x1003195c3 &lt;+115&gt;: movdqa -0x20(%rbp), %xmm6 0x1003195c8 &lt;+120&gt;: popq %rax 0x1003195c9 &lt;+121&gt;: movdqa -0x10(%rbp), %xmm7 0x1003195ce &lt;+126&gt;: testq %r11, %r11 0x1003195d1 &lt;+129&gt;: leave 0x1003195d2 &lt;+130&gt;: jmpq *%r11. // 未做调整，直接调用了IMP（_trim_unrecognized_default_imp_） 0x1003195d5 &lt;+133&gt;: nopl (%rax) 从_class_lookupMethodAndLoadCache3查询出IMP后，就直接假设IMP会处理struct返回值，实际上我们提供的默认实现，并不支持，将structReturnAddr当作了self来解读，然后出现了BAD_ACCESS！ 如何避免返回值为struct下的BAD_ACCESS呢？编译器根据接口推断出了该使用objc_msgsend还是objc_msgsend_stret，使用[testObject performSelector:@selector(methodReturnsACGRect)]进行调用，可以成功预防。performSelector的返回值为id，走的还是objc_msgsend，@selector(methodReturnsACGRect)的调用完全依赖于其MethodSignature中对参数和返回值的描述，也走objc_msgsend，因此不会出现问题。但是直接调用的情况下该如何处理，暂无思路，先放下对此种情况下的保护。 小结利用resolveInstanceMethod:动态提供IMP实现的方案优缺点如下：优点：暂无缺点：1、respondsToSelector:测试对象是否响应selector时，也会触发resolveInstanceMethod:添加方法，对正常使用干扰很大，例如使用代理delegate的情况，经常会先respondsToSelector:测试一下代理，看其有无实现相关方法。delegate会被误加上错误的实现，出现不可预料的错误！2、不能保护声明了返回值为CGRect但是没有提供的方法。 实现2:利用forwardingTargetForSelector:提供转发对象实现代码如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657id _tft_unrecognized_default_imp_(id self, SEL sel) &#123; return nil;&#125;#pragma mark - _TFT_ForwradingTargetClass@interface _TFT_ForwradingTargetClass : NSObject@end@implementation _TFT_ForwradingTargetClass@end@implementation NSObject (TypeForwardingTarget)+ (void)TFT_startUnrecognizedSelectorProtection &#123; [self TFT_exchangeForwardingTargetForSelectorMethod];&#125;+ (void)TFT_stopUnrecognizedSelectorProtection &#123; [self TFT_exchangeForwardingTargetForSelectorMethod];&#125;+ (void)TFT_exchangeForwardingTargetForSelectorMethod &#123; [[self class] ra_swizzleInstanceMethodWithOriginalSEL:@selector(forwardingTargetForSelector:) swizzledSEL:@selector(TFT_forwardingTargetForSelector:)];&#125;- (id)TFT_forwardingTargetForSelector:(SEL)aSelector &#123; // 检查此类是否通过forwardingTargetForSelector:实现消息转发 id forwardingTarget = [self TFT_forwardingTargetForSelector:aSelector]; // 若子类已经重写，避免干扰子类的流程，直接返回NSObject的实现 if ([[self class] ra_isMethodOveridedNSObjectImplementationForSelector:@selector(forwardingTargetForSelector:) isClassMethod:NO]) &#123; return forwardingTarget; &#125; // 检查此类是否通过forwardingTargetForSelector:实现了转发流程 if (!forwardingTarget) &#123; NSMethodSignature *sig = [self methodSignatureForSelector:aSelector]; if (sig != nil) &#123; return forwardingTarget; &#125; &#125; // 获取一个转发代理实例 if (!forwardingTarget) &#123; forwardingTarget = [self TFT_instanceOfForwardingTargetClassWithSelector:aSelector]; &#125; return forwardingTarget;&#125;- (id)TFT_instanceOfForwardingTargetClassWithSelector:(SEL)aSelector &#123; Class forwardingTargetClass = [_TFT_ForwradingTargetClass class]; class_addMethod(forwardingTargetClass, aSelector, (IMP)_tft_unrecognized_default_imp_, \"@@:\"); id instance = [[forwardingTargetClass alloc] init]; return instance;&#125; 实现思路若子类重写了forwardingTargetForSelector:就不启用保护了。若子类通过methodSignatureForSelector:实现转发流程，也不对这些selector做保护。其他情况下，给stub类forwardingTargetClass添加未能识别的selector的实现，使其可以响应此selector的消息，然后创建forwardingTargetClass实例，作为消息转发对象。 测试结果返回值为CGRect时同样会出现BAD_ACCESS，原因和实现1中描述的是一样的。 小结利用forwardingTargetForSelector:动态提供IMP实现的方案优缺点如下：优点：1、respondsToSelector:不会触发消息转发流程，不干扰respondsToSelector:测试结果。缺点：1、不能保护声明了返回值为CGRect但是没有提供的方法。 实现3:利用forwardInvocation:转发消息实现代码如下:12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485id _tfi_unrecognized_default_imp_(id self, SEL sel) &#123; return nil;&#125;#pragma mark - _TFI_ForwradingClass@interface _TFI_ForwradingClass : NSObject- (id)dummyMethod;@end@implementation _TFI_ForwradingClass- (id)dummyMethod &#123; return nil;&#125;@end#pragma mark - TypeForwardInvocation@implementation NSObject (TypeForwardInvocation)+ (void)TFI_startUnrecognizedSelectorProtection &#123; [self TFI_exchangeMethodSignatureForSelectorMethod]; [self TFI_exchangeForwardInvocationMethod];&#125;+ (void)TFI_stopUnrecognizedSelectorProtection &#123; [self TFI_exchangeMethodSignatureForSelectorMethod]; [self TFI_exchangeForwardInvocationMethod];&#125;+ (void)TFI_exchangeMethodSignatureForSelectorMethod &#123; [[self class] ra_swizzleInstanceMethodWithOriginalSEL:@selector(methodSignatureForSelector:) swizzledSEL:@selector(TFI_methodSignatureForSelector:)];&#125;+ (void)TFI_exchangeForwardInvocationMethod &#123; [[self class] ra_swizzleInstanceMethodWithOriginalSEL:@selector(forwardInvocation:) swizzledSEL:@selector(TFI_forwardInvocation:)];&#125;- (NSMethodSignature *)TFI_methodSignatureForSelector:(SEL)aSelector &#123; NSMethodSignature *sig = [self TFI_methodSignatureForSelector:aSelector]; // 若子类已经重写，避免干扰子类的流程，直接返回NSObject的实现 if ([[self class] ra_isMethodOveridedNSObjectImplementationForSelector:@selector(methodSignatureForSelector:) isClassMethod:NO]) &#123; return sig; &#125; if (!sig) &#123; // 标记原来的类未针对aSelector实现转发，返回一个默认的sig CPThreadSafeCounter *counter = [self TFI_unrecognizedSelectorCacheSet]; if (!counter) &#123; counter = [[CPThreadSafeCounter alloc] init]; [self TFI_setUnrecognizedSelectorCacheSet:counter]; &#125; [counter addCountForObject:NSStringFromSelector(aSelector)]; sig = [_TFI_ForwradingClass instanceMethodSignatureForSelector:@selector(dummyMethod)]; &#125; return sig;&#125;- (void)TFI_forwardInvocation:(NSInvocation *)anInvocation &#123; SEL aSelector = [anInvocation selector]; // 判断原来的类中是否实现了转发 CPThreadSafeCounter *counter = [self TFI_unrecognizedSelectorCacheSet]; if ([counter isZeroCountForObject:NSStringFromSelector(aSelector)]) &#123; [self TFI_forwardInvocation:anInvocation]; &#125; else &#123; // 添加个空方法，然后发起调用 class_addMethod([_TFI_ForwradingClass class], aSelector, (IMP)_tfi_unrecognized_default_imp_, \"@@:\"); [anInvocation invokeWithTarget:[[_TFI_ForwradingClass alloc] init]]; [counter decreaseCountForObject:NSStringFromSelector(aSelector)]; &#125;&#125;#pragma mark - Getter &amp; Setter- (void)TFI_setUnrecognizedSelectorCacheSet:(CPThreadSafeCounter *)set &#123; objc_setAssociatedObject(self, @selector(TFI_unrecognizedSelectorCacheSet), set, OBJC_ASSOCIATION_RETAIN);&#125;- (id)TFI_unrecognizedSelectorCacheSet &#123; return objc_getAssociatedObject(self, _cmd);&#125; 实现思路若子类重写了methodSignatureForSelector:就不启用保护了。实现中利用_TFI_ForwradingClass类提供未识别selector的NSMethodSignature同时也作为anInvocation的target。利用CPThreadSafeCounter在TFI_methodSignatureForSelector:方法中标记开启了保护的selector。在TFI_forwardInvocation:方法中，动态为_TFI_ForwradingClass添加未识别selector的默认实现，使其可以响应。 测试结果返回值为CGRect时同样会出现BAD_ACCESS，原因和实现1中描述的是一样的。 小结利用forwardInvocation:动态提供IMP实现的方案优缺点如下：优点：1、respondsToSelector:不会触发消息转发流程，不干扰respondsToSelector:测试结果。缺点：1、不能保护声明了返回值为CGRect但是没有提供的方法。2、效率低于forwardingTargetForSelector:的实现。 总结实现1(利用resolveInstanceMethod:动态提供方法的IMP)干扰当了respondsToSelector:不适合使用。实现2(利用forwardingTargetForSelector:提供转发对象)和实现3(利用forwardInvocation:转发消息)都可以使用，实现2比实现3更高效。 缺陷 无法保护返回为CGRect的方法，且会将Unrecognized Selector Crash转移成BAD_ACCESS崩溃，需要添加额外信息，以避免使问题更难定位。 无法保护重些动态方法决议/消息转发方法的类。 参考文献ObjCRuntimeGuideobjc explain: objc_msgSend_stretInspecting Obj-C parameters in gdbx86-64 Instructions and ABI小萝莉说Crash系列大白健康系统","categories":[{"name":"探索","slug":"探索","permalink":"http://yoursite.com/categories/探索/"}],"tags":[{"name":"Unrecognized Selector Crash","slug":"Unrecognized-Selector-Crash","permalink":"http://yoursite.com/tags/Unrecognized-Selector-Crash/"},{"name":"崩溃预防","slug":"崩溃预防","permalink":"http://yoursite.com/tags/崩溃预防/"}]},{"title":"记一次+initialize:函数线程安全问题导致的崩溃","slug":"DebugInitializeSignal11Crash","date":"2017-12-11T07:53:27.000Z","updated":"2017-12-11T09:40:10.771Z","comments":true,"path":"2017/12/11/DebugInitializeSignal11Crash/","link":"","permalink":"http://yoursite.com/2017/12/11/DebugInitializeSignal11Crash/","excerpt":"崩溃信息崩溃线程：任意线程崩溃栈：Application received signal 11 1234567891 libobjc.A.dylib 0x1800bc148 _objc_msgSend + 82 CoreFoundation 0x181642cf8 ___rehashd + 1443 CoreFoundation 0x18152a434 -[__NSDictionaryM setObject:forKey:] + 6764 MyApp 0x10027ba04 +[BaseDataModel initialize] (BaseDataModel.m:31)5 libobjc.A.dylib 0x1800a9418 _CALLING_SOME_+initialize_METHOD + 246 libobjc.A.dylib 0x1800a9684 __class_initialize + 6127 libobjc.A.dylib 0x1800b14b4 _lookUpImpOrForward + 2288 libobjc.A.dylib 0x1800bc478 __objc_msgSend_uncached + 569 MyApp 0x1001bbf64 -[HeartRateManager loadNewestdayHeartRateWithUserId:deviceId:] (HeartRateManager.m:1413) 用户使用轨迹：系统分布： 分析看使用轨迹是用户刚打开App，BaseDataModel在+initialize:函数中做某些初始化操作时发生了崩溃。看看崩溃函数相关的源码： 123456789101112131415161718192021222324static NSMutableDictionary* gClassRemovedPropertiesMapDict = nil;@implementation BaseDataModel+(void)initialize&#123; //记录当前所有的Properties,没有映射的就remove掉 if (gClassRemovedPropertiesMapDict == nil) &#123; gClassRemovedPropertiesMapDict = [NSMutableDictionary dictionary]; &#125; LKModelInfos* info = [[self class] getModelInfos]; NSMutableArray* pptArray = [NSMutableArray array]; for (int i = 0; i &lt; info.count; ++i) &#123; LKDBProperty* ppt = [info objectWithIndex:i]; NSString* pptName = ppt.propertyName; [pptArray addObject:pptName]; &#125; // 崩溃的函数 [gClassRemovedPropertiesMapDict setObject:pptArray forKey:NSStringFromClass([self class])]; [self mapRelation];&#125;@end 崩溃栈顶的函数为_objc_msgSend，出现在可变字典设置键值对时: 1[gClassRemovedPropertiesMapDict setObject:pptArray forKey:NSStringFromClass([self class])]; 由于NSMutableDictionary为非线程安全，在多个线程同时访问时会出现问题。但是印象中，+initialize:应该是线程安全的，当ClassA在ThreadA上被触发+initialize:时，其他线程向此类的发起的消息都会被阻塞。+initialize:的注释如下： Initializes the class before it receives its first message.The runtime sends initialize to each class in a program just before the class, or any class that inherits from it, is sent its first message from within the program. Superclasses receive this message before their subclasses. The runtime sends the initialize message to classes in a thread-safe manner. That is, initialize is run by the first thread to send a message to a class, and any other thread that tries to send a message to that class will block until initialize completes. 如上面所说，当ClassA在ThreadA上被触发+initialize:时，其他线程线程向此类的发起的消息都会被阻塞。 The superclass implementation may be called multiple times if subclasses do not implement initialize—the runtime will call the inherited implementation—or if subclasses explicitly call [super initialize]. If you want to protect yourself from being run multiple times, you can structure your implementation along these lines: 但是上面一段又补充道：当子类没有实现+initialize:方法时，父类的+initialize:方法就会被调用。这点倒是符合BaseDataModel的+initialize:被调用的场景。继承于BaseDataModel的DataModel，都没有实现+initialize:方法，均依赖于父类BaseDataModel的+initialize:方法来做初始化。那在这中场景下，共享了父类中的+initialize:实现的两个子类，当在两个线程同时调起时，其+initialize:调用逻辑是串行安全的？还是并行执行的？","text":"崩溃信息崩溃线程：任意线程崩溃栈：Application received signal 11 1234567891 libobjc.A.dylib 0x1800bc148 _objc_msgSend + 82 CoreFoundation 0x181642cf8 ___rehashd + 1443 CoreFoundation 0x18152a434 -[__NSDictionaryM setObject:forKey:] + 6764 MyApp 0x10027ba04 +[BaseDataModel initialize] (BaseDataModel.m:31)5 libobjc.A.dylib 0x1800a9418 _CALLING_SOME_+initialize_METHOD + 246 libobjc.A.dylib 0x1800a9684 __class_initialize + 6127 libobjc.A.dylib 0x1800b14b4 _lookUpImpOrForward + 2288 libobjc.A.dylib 0x1800bc478 __objc_msgSend_uncached + 569 MyApp 0x1001bbf64 -[HeartRateManager loadNewestdayHeartRateWithUserId:deviceId:] (HeartRateManager.m:1413) 用户使用轨迹：系统分布： 分析看使用轨迹是用户刚打开App，BaseDataModel在+initialize:函数中做某些初始化操作时发生了崩溃。看看崩溃函数相关的源码： 123456789101112131415161718192021222324static NSMutableDictionary* gClassRemovedPropertiesMapDict = nil;@implementation BaseDataModel+(void)initialize&#123; //记录当前所有的Properties,没有映射的就remove掉 if (gClassRemovedPropertiesMapDict == nil) &#123; gClassRemovedPropertiesMapDict = [NSMutableDictionary dictionary]; &#125; LKModelInfos* info = [[self class] getModelInfos]; NSMutableArray* pptArray = [NSMutableArray array]; for (int i = 0; i &lt; info.count; ++i) &#123; LKDBProperty* ppt = [info objectWithIndex:i]; NSString* pptName = ppt.propertyName; [pptArray addObject:pptName]; &#125; // 崩溃的函数 [gClassRemovedPropertiesMapDict setObject:pptArray forKey:NSStringFromClass([self class])]; [self mapRelation];&#125;@end 崩溃栈顶的函数为_objc_msgSend，出现在可变字典设置键值对时: 1[gClassRemovedPropertiesMapDict setObject:pptArray forKey:NSStringFromClass([self class])]; 由于NSMutableDictionary为非线程安全，在多个线程同时访问时会出现问题。但是印象中，+initialize:应该是线程安全的，当ClassA在ThreadA上被触发+initialize:时，其他线程向此类的发起的消息都会被阻塞。+initialize:的注释如下： Initializes the class before it receives its first message.The runtime sends initialize to each class in a program just before the class, or any class that inherits from it, is sent its first message from within the program. Superclasses receive this message before their subclasses. The runtime sends the initialize message to classes in a thread-safe manner. That is, initialize is run by the first thread to send a message to a class, and any other thread that tries to send a message to that class will block until initialize completes. 如上面所说，当ClassA在ThreadA上被触发+initialize:时，其他线程线程向此类的发起的消息都会被阻塞。 The superclass implementation may be called multiple times if subclasses do not implement initialize—the runtime will call the inherited implementation—or if subclasses explicitly call [super initialize]. If you want to protect yourself from being run multiple times, you can structure your implementation along these lines: 但是上面一段又补充道：当子类没有实现+initialize:方法时，父类的+initialize:方法就会被调用。这点倒是符合BaseDataModel的+initialize:被调用的场景。继承于BaseDataModel的DataModel，都没有实现+initialize:方法，均依赖于父类BaseDataModel的+initialize:方法来做初始化。那在这中场景下，共享了父类中的+initialize:实现的两个子类，当在两个线程同时调起时，其+initialize:调用逻辑是串行安全的？还是并行执行的？ 重现和实验重现的逻辑可以直接模仿BaseDataModel的使用逻辑，声明TestObect类来担当BaseDataModel的角色。利用objc可以在运行时添加子类的特性，每次添加子类的代码抛到并行队列中，并循环1000次提高重现概率。在+initialize:函数中，开始和结束的位置分别打上start和end标记，并在终端中输出。代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950static NSMutableDictionary *gMapDict = nil;@interface TestObect : NSObject@end@implementation TestObect+ (void)initialize &#123; // 打印开始，记录线程 NSLog(@&quot;start from thread %@&quot;, [NSThread currentThread]); if (gMapDict == nil) &#123; gMapDict = [[NSMutableDictionary alloc] init]; &#125; NSString *className = NSStringFromClass(self); NSString *dumyInfo = [className copy]; [gMapDict setObject:dumyInfo forKey:className]; // 打印结束，记录线程 NSLog(@&quot;end from thread %@&quot;, [NSThread currentThread]);&#125;- (NSString *)aMethond &#123; return @&quot;aMessage&quot;;&#125;@end@interface AppDelegate ()@end@implementation AppDelegate- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions &#123; // Override point for customization after application launch. for (NSInteger i = 0; i &lt; 1000; i++) &#123; dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123; // 动态创建TestObect子类并创建一个实例 NSString *className = [NSString stringWithFormat:@&quot;TestObectSubclass_%@&quot;, @(i)]; Class c = objc_allocateClassPair([TestObect class], className.UTF8String, 0); objc_registerClassPair(c); //向TestObect子类实例发送消息，触发initialize:函数 id anInstance = [[c alloc] init]; &#125;); &#125; return YES;&#125;@end 输出结果为： 123456789101112132017-12-11 15:49:08.392546+0800 TestProject[7871:3491896] start from thread &lt;NSThread: 0x1d006a100&gt;&#123;number = 3, name = (null)&#125;2017-12-11 15:49:08.392598+0800 TestProject[7871:3491896] end from thread &lt;NSThread: 0x1d006a100&gt;&#123;number = 3, name = (null)&#125;2017-12-11 15:49:08.393337+0800 TestProject[7871:3491896] start from thread &lt;NSThread: 0x1d006a100&gt;&#123;number = 3, name = (null)&#125;2017-12-11 15:49:08.393402+0800 TestProject[7871:3491894] start from thread &lt;NSThread: 0x1d0070d80&gt;&#123;number = 4, name = (null)&#125;2017-12-11 15:49:08.393559+0800 TestProject[7871:3491895] start from thread &lt;NSThread: 0x1d4677200&gt;&#123;number = 5, name = (null)&#125;2017-12-11 15:49:08.393614+0800 TestProject[7871:3491897] start from thread &lt;NSThread: 0x1cc06a180&gt;&#123;number = 6, name = (null)&#125;2017-12-11 15:49:08.393761+0800 TestProject[7871:3491894] end from thread &lt;NSThread: 0x1d0070d80&gt;&#123;number = 4, name = (null)&#125;2017-12-11 15:49:08.393759+0800 TestProject[7871:3491896] end from thread &lt;NSThread: 0x1d006a100&gt;&#123;number = 3, name = (null)&#125;2017-12-11 15:49:08.393811+0800 TestProject[7871:3491902] start from thread &lt;NSThread: 0x1d46771c0&gt;&#123;number = 7, name = (null)&#125;2017-12-11 15:49:08.393970+0800 TestProject[7871:3491895] end from thread &lt;NSThread: 0x1d4677200&gt;&#123;number = 5, name = (null)&#125;2017-12-11 15:49:08.393993+0800 TestProject[7871:3491903] start from thread &lt;NSThread: 0x1cc06a0c0&gt;&#123;number = 9, name = (null)&#125;2017-12-11 15:49:08.394019+0800 TestProject[7871:3491903] end from thread &lt;NSThread: 0x1cc06a0c0&gt;&#123;number = 9, name = (null)&#125;2017-12-11 15:49:08.394045+0800 TestProject[7871:3491902] end from thread 出现了崩溃：输出结果为：多个start,end混杂在一起，而不是start-&gt;end，start-&gt;end，start-&gt;end，start-&gt;end的串行输出，说明共享了父类中的+initialize:实现的多个子类，当在两个线程同时调起时，其+initialize:调用逻辑是并行执行的。 +initialize:的线程安全特性任意一个类的+initialize:方法只会在触发线程中调用，其他向此类发起的消息均会被阻塞。同一父类的不同子类的+initialize:是可以并行执行的，无论这些子类是继承了父类的实现还是重写了。 解决方法将NSMutableDictionary替换为线程的安全的类来缓存信息即可。由于BaseDataModel的+initialize:中的缓存逻辑不会触发其他BaseDataModel的子类的初始化，所以不存在死锁的情况。","categories":[{"name":"踩坑记录","slug":"踩坑记录","permalink":"http://yoursite.com/categories/踩坑记录/"},{"name":"崩溃定位及预防","slug":"踩坑记录/崩溃定位及预防","permalink":"http://yoursite.com/categories/踩坑记录/崩溃定位及预防/"}],"tags":[{"name":"踩坑记录","slug":"踩坑记录","permalink":"http://yoursite.com/tags/踩坑记录/"},{"name":"崩溃分析","slug":"崩溃分析","permalink":"http://yoursite.com/tags/崩溃分析/"}]},{"title":"记一次UIWebView signal 11崩溃定位","slug":"DebugWebViewSignal11Crash2","date":"2017-12-11T05:28:20.000Z","updated":"2017-12-11T07:04:39.946Z","comments":true,"path":"2017/12/11/DebugWebViewSignal11Crash2/","link":"","permalink":"http://yoursite.com/2017/12/11/DebugWebViewSignal11Crash2/","excerpt":"崩溃信息线程：WebThread崩溃栈： 1234567891011121 libGPUSupportMercury.dylib 0x190e66f90 &lt;redacted&gt;2 AGXGLDriver 0x19587e1bc _gldUpdateDispatch3 libGPUSupportMercury.dylib 0x190e67f40 _gpusSubmitDataBuffers4 AGXGLDriver 0x19587f77c _gldUpdateDispatch5 GLEngine 0x1960c3a80 _gliBindViewES6 OpenGLES 0x183c8eb20 -[EAGLContext renderbufferStorage:fromDrawable:] + 5047 WebCore 0x1865de15c WebCore::GraphicsContext3D::~GraphicsContext3D() + 1168 WebCore 0x186fb895c WebCore::WebGLRenderingContextBase::destroyGraphicsContext3D() + 1489 WebCore 0x186fb82ac WebCore::WebGLRenderingContextBase::~WebGLRenderingContextBase() + 74410 WebCore 0x186fb5c0c WebCore::WebGLRenderingContext::~WebGLRenderingContext() + 1211 WebCore 0x18660e8e4 WebCore::HTMLCanvasElement::~HTMLCanvasElement() + 20012 WebCore 0x18660ea98 WebCore::HTMLCanvasElement::~HTMLCanvasElement() + 12 用户使用轨迹：系统分布：webview加载的链接：https://h5.youzan.com/v2/common/prefetching","text":"崩溃信息线程：WebThread崩溃栈： 1234567891011121 libGPUSupportMercury.dylib 0x190e66f90 &lt;redacted&gt;2 AGXGLDriver 0x19587e1bc _gldUpdateDispatch3 libGPUSupportMercury.dylib 0x190e67f40 _gpusSubmitDataBuffers4 AGXGLDriver 0x19587f77c _gldUpdateDispatch5 GLEngine 0x1960c3a80 _gliBindViewES6 OpenGLES 0x183c8eb20 -[EAGLContext renderbufferStorage:fromDrawable:] + 5047 WebCore 0x1865de15c WebCore::GraphicsContext3D::~GraphicsContext3D() + 1168 WebCore 0x186fb895c WebCore::WebGLRenderingContextBase::destroyGraphicsContext3D() + 1489 WebCore 0x186fb82ac WebCore::WebGLRenderingContextBase::~WebGLRenderingContextBase() + 74410 WebCore 0x186fb5c0c WebCore::WebGLRenderingContext::~WebGLRenderingContext() + 1211 WebCore 0x18660e8e4 WebCore::HTMLCanvasElement::~HTMLCanvasElement() + 20012 WebCore 0x18660ea98 WebCore::HTMLCanvasElement::~HTMLCanvasElement() + 12 用户使用轨迹：系统分布：webview加载的链接：https://h5.youzan.com/v2/common/prefetching 分析综合上面的信息，用户是在浏览与https://h5.youzan.com/v2/common/prefetching相关的网页，进入后台一段时间后就发生崩溃。根据官方的Technical Note How to fix OpenGL ES application crashes when moving to the background，类比下崩溃栈，可以确定下来是webview在后台调用OPenGL ES进行渲染所致。在重现中也发现，除了加载https://h5.youzan.com/v2/common/prefetching时进入后台可能会崩溃，加载含WebGL动画的网页时进入后台也容易出现崩溃。 解决方案监听WillResignActive通知，强制加载一个空白界面，在WillEnterForground时再重新加载原来的链接。但是会导致重新加载界面，用户体验不佳。后面尝试切换至WKWebView，加载上述两个链接时进入后台均不会出发崩溃。所以最终放弃了UIWebView转向了WKWebView。","categories":[{"name":"踩坑记录","slug":"踩坑记录","permalink":"http://yoursite.com/categories/踩坑记录/"},{"name":"崩溃定位及预防","slug":"踩坑记录/崩溃定位及预防","permalink":"http://yoursite.com/categories/踩坑记录/崩溃定位及预防/"}],"tags":[{"name":"踩坑记录","slug":"踩坑记录","permalink":"http://yoursite.com/tags/踩坑记录/"},{"name":"崩溃分析","slug":"崩溃分析","permalink":"http://yoursite.com/tags/崩溃分析/"}]},{"title":"记一次UIWebView _WTFCrash崩溃定位","slug":"DebugWebViewSignal11Crash","date":"2017-12-08T08:28:20.000Z","updated":"2017-12-11T07:05:16.160Z","comments":true,"path":"2017/12/08/DebugWebViewSignal11Crash/","link":"","permalink":"http://yoursite.com/2017/12/08/DebugWebViewSignal11Crash/","excerpt":"_WTFCrash 崩溃信息线程：WebThread崩溃栈： 123456789101112131415161718192021JavaScriptCore 0x1835449e4 _WTFCrash + 72JavaScriptCore 0x1835449dc _WTFCrash + 64JavaScriptCore 0x183445864 JSC::JSLock::DropAllLocks::DropAllLocks(JSC::VM*) + 0WebCore 0x18f6ffc44 SendDelegateMessage(NSInvocation*)CoreFoundation 0x181cb6230 ____forwarding___ + 440CoreFoundation 0x181bbab6c ___forwarding_prep_0___ + 92WebKitLegacy 0x1905a717c -[_WebSafeForwarder forwardInvocation:]WebCore 0x1900c9440 &lt;redacted&gt;WebCore 0x18f70a348 &lt;redacted&gt;WebCore 0x18f73ee68 &lt;redacted&gt;WebCore 0x18f73ecf4 __ZN7WebCore11FrameLoader4loadERKNS_16FrameLoadRequestEWebKitLegacy 0x190578c00 &lt;redacted&gt;WebCore 0x1903ae23c &lt;redacted&gt;CoreFoundation 0x181c6a9ec ___CFRUNLOOP_IS_CALLING_OUT_TO_A_SOURCE0_PERFORM_FUNCTION__ + 24CoreFoundation 0x181c69c90 ___CFRunLoopDoSources0 + 264CoreFoundation 0x181c67d40 ___CFRunLoopRun + 712CoreFoundation 0x181b950a4 _CFRunLoopRunSpecific + 396WebCore 0x18f6e4858 &lt;redacted&gt;libsystem_pthread.dylib 0x192c2fe80 &lt;redacted&gt;libsystem_pthread.dylib 0x192c2fddc &lt;redacted&gt;libsystem_pthread.dylib 0x192c2cfb0 _thread_start 用户使用轨迹：任意WUIWebView实例，用户浏览内链内容时容易出现。系统版本：集中在iOS 8上。 分析根据Bug 139654: DropAllLocks RELEASE_ASSERT on iOS的bug分析，这应该是UIWebView在iOS 8上的bug。","text":"_WTFCrash 崩溃信息线程：WebThread崩溃栈： 123456789101112131415161718192021JavaScriptCore 0x1835449e4 _WTFCrash + 72JavaScriptCore 0x1835449dc _WTFCrash + 64JavaScriptCore 0x183445864 JSC::JSLock::DropAllLocks::DropAllLocks(JSC::VM*) + 0WebCore 0x18f6ffc44 SendDelegateMessage(NSInvocation*)CoreFoundation 0x181cb6230 ____forwarding___ + 440CoreFoundation 0x181bbab6c ___forwarding_prep_0___ + 92WebKitLegacy 0x1905a717c -[_WebSafeForwarder forwardInvocation:]WebCore 0x1900c9440 &lt;redacted&gt;WebCore 0x18f70a348 &lt;redacted&gt;WebCore 0x18f73ee68 &lt;redacted&gt;WebCore 0x18f73ecf4 __ZN7WebCore11FrameLoader4loadERKNS_16FrameLoadRequestEWebKitLegacy 0x190578c00 &lt;redacted&gt;WebCore 0x1903ae23c &lt;redacted&gt;CoreFoundation 0x181c6a9ec ___CFRUNLOOP_IS_CALLING_OUT_TO_A_SOURCE0_PERFORM_FUNCTION__ + 24CoreFoundation 0x181c69c90 ___CFRunLoopDoSources0 + 264CoreFoundation 0x181c67d40 ___CFRunLoopRun + 712CoreFoundation 0x181b950a4 _CFRunLoopRunSpecific + 396WebCore 0x18f6e4858 &lt;redacted&gt;libsystem_pthread.dylib 0x192c2fe80 &lt;redacted&gt;libsystem_pthread.dylib 0x192c2fddc &lt;redacted&gt;libsystem_pthread.dylib 0x192c2cfb0 _thread_start 用户使用轨迹：任意WUIWebView实例，用户浏览内链内容时容易出现。系统版本：集中在iOS 8上。 分析根据Bug 139654: DropAllLocks RELEASE_ASSERT on iOS的bug分析，这应该是UIWebView在iOS 8上的bug。 解决办法既然这是iOS 8系统的Bug，且我们AppiOS 10/9的系统版本用户占比较大，可以直接忽略此崩溃。 无心插柳柳成荫在含有这个崩溃的版本里，H5与App的通信，是App通过UIWebView的私有属性获取到了UIWebView实例的JSContext，在context上设置全局bridge对象来实现的。 1JSContext *context = [webView valueForKeyPath:@&quot;documentView.webView.mainFrame.javaScriptContext&quot;]; 随着iOS审核对私有API使用变的严格，同时私有API也有可能在后续的系统版本中发生变化，所以决定在新版中使用拦截含特定scheme的url实现H5于App间的通信。然后在这个新版本中iOS 8上就没有出现过_WTFCrash了。 1234SendDelegateMessage(NSInvocation*)CoreFoundation 0x181cb6230 ____forwarding___ + 440CoreFoundation 0x181bbab6c ___forwarding_prep_0___ + 92WebKitLegacy 0x1905a717c -[_WebSafeForwarder forwardInvocation:] 结合上面的崩溃栈，可能这和js-&gt;javascriptCore-&gt;JSContext-&gt;OC_ExportObject消息传递过程中的锁管理有一定的关系。","categories":[{"name":"踩坑记录","slug":"踩坑记录","permalink":"http://yoursite.com/categories/踩坑记录/"},{"name":"崩溃定位及预防","slug":"踩坑记录/崩溃定位及预防","permalink":"http://yoursite.com/categories/踩坑记录/崩溃定位及预防/"}],"tags":[{"name":"踩坑记录","slug":"踩坑记录","permalink":"http://yoursite.com/tags/踩坑记录/"},{"name":"崩溃分析","slug":"崩溃分析","permalink":"http://yoursite.com/tags/崩溃分析/"}]},{"title":"记一次Signal 5崩溃定位（NotDone）","slug":"DebugSignal5Crash","date":"2017-12-08T03:31:45.000Z","updated":"2017-12-11T07:05:38.350Z","comments":true,"path":"2017/12/08/DebugSignal5Crash/","link":"","permalink":"http://yoursite.com/2017/12/08/DebugSignal5Crash/","excerpt":"崩溃栈123456789101112131415161718192021222324252627* 1 libdispatch.dylib 0x180506bb0 __dispatch_queue_resume + 624* 2 CoreFoundation 0x18160e22c ___CFNOTIFICATIONCENTER_IS_CALLING_OUT_TO_AN_OBSERVER__ + 20* 3 CoreFoundation 0x18160e22c ___CFNOTIFICATIONCENTER_IS_CALLING_OUT_TO_AN_OBSERVER__ + 20* 4 CoreFoundation 0x18160d930 __CFXRegistrationPost + 400* 5 CoreFoundation 0x18160d6ac ____CFXNotificationPost_block_invoke + 60* 6 CoreFoundation 0x18167cb9c -[_CFXNotificationRegistrar find:object:observer:enumerator:] + 1504* 7 CoreFoundation 0x18154fbf4 __CFXNotificationPost + 376* 8 Foundation 0x1820566bc -[NSNotificationCenter postNotificationName:object:userInfo:] + 68* 9 UIKit 0x18771d9d8 -[UIApplication _sendWillEnterForegroundCallbacks] + 232* 10 UIKit 0x187758ebc -[UIApplication _handleApplicationActivationWithScene:transitionContext:completion:] + 2140* 11 UIKit 0x1877583ec -[UIApplication _handleApplicationLifecycleEventWithScene:transitionContext:completion:] + 452* 12 UIKit 0x187743ae8 ___70-[UIApplication scene:didUpdateWithDiff:transitionContext:completion:]_block_invoke + 152* 13 UIKit 0x18774376c -[UIApplication scene:didUpdateWithDiff:transitionContext:completion:] + 888* 14 UIKit 0x187a75034 -[UIApplicationSceneClientAgent scene:handleEvent:withCompletion:] + 464* 15 FrontBoardServices 0x1831e7bd4 &lt;redacted&gt;* 16 FrontBoardServices 0x183215904 &lt;redacted&gt;* 17 FrontBoardServices 0x183215770 &lt;redacted&gt;* 18 FrontBoardServices 0x183215b18 &lt;redacted&gt;* 19 CoreFoundation 0x181622278 ___CFRUNLOOP_IS_CALLING_OUT_TO_A_SOURCE0_PERFORM_FUNCTION__ + 24* 20 CoreFoundation 0x181621bc0 ___CFRunLoopDoSources0 + 524* 21 CoreFoundation 0x18161f7c0 ___CFRunLoopRun + 804* 22 CoreFoundation 0x18154e048 _CFRunLoopRunSpecific + 444* 23 GraphicsServices 0x182fd1198 _GSEventRunModal + 180* 24 UIKit 0x187527818 -[UIApplication _run] + 684* 25 UIKit 0x187522550 _UIApplicationMain + 208* 26 App 0x1005d3268 _main (main.m:16)* 27 libdyld.dylib 0x1805305b8 _start + 4 信息收集先确定下signal 5崩溃的原因是啥，signal.h定义的signal如下：","text":"崩溃栈123456789101112131415161718192021222324252627* 1 libdispatch.dylib 0x180506bb0 __dispatch_queue_resume + 624* 2 CoreFoundation 0x18160e22c ___CFNOTIFICATIONCENTER_IS_CALLING_OUT_TO_AN_OBSERVER__ + 20* 3 CoreFoundation 0x18160e22c ___CFNOTIFICATIONCENTER_IS_CALLING_OUT_TO_AN_OBSERVER__ + 20* 4 CoreFoundation 0x18160d930 __CFXRegistrationPost + 400* 5 CoreFoundation 0x18160d6ac ____CFXNotificationPost_block_invoke + 60* 6 CoreFoundation 0x18167cb9c -[_CFXNotificationRegistrar find:object:observer:enumerator:] + 1504* 7 CoreFoundation 0x18154fbf4 __CFXNotificationPost + 376* 8 Foundation 0x1820566bc -[NSNotificationCenter postNotificationName:object:userInfo:] + 68* 9 UIKit 0x18771d9d8 -[UIApplication _sendWillEnterForegroundCallbacks] + 232* 10 UIKit 0x187758ebc -[UIApplication _handleApplicationActivationWithScene:transitionContext:completion:] + 2140* 11 UIKit 0x1877583ec -[UIApplication _handleApplicationLifecycleEventWithScene:transitionContext:completion:] + 452* 12 UIKit 0x187743ae8 ___70-[UIApplication scene:didUpdateWithDiff:transitionContext:completion:]_block_invoke + 152* 13 UIKit 0x18774376c -[UIApplication scene:didUpdateWithDiff:transitionContext:completion:] + 888* 14 UIKit 0x187a75034 -[UIApplicationSceneClientAgent scene:handleEvent:withCompletion:] + 464* 15 FrontBoardServices 0x1831e7bd4 &lt;redacted&gt;* 16 FrontBoardServices 0x183215904 &lt;redacted&gt;* 17 FrontBoardServices 0x183215770 &lt;redacted&gt;* 18 FrontBoardServices 0x183215b18 &lt;redacted&gt;* 19 CoreFoundation 0x181622278 ___CFRUNLOOP_IS_CALLING_OUT_TO_A_SOURCE0_PERFORM_FUNCTION__ + 24* 20 CoreFoundation 0x181621bc0 ___CFRunLoopDoSources0 + 524* 21 CoreFoundation 0x18161f7c0 ___CFRunLoopRun + 804* 22 CoreFoundation 0x18154e048 _CFRunLoopRunSpecific + 444* 23 GraphicsServices 0x182fd1198 _GSEventRunModal + 180* 24 UIKit 0x187527818 -[UIApplication _run] + 684* 25 UIKit 0x187522550 _UIApplicationMain + 208* 26 App 0x1005d3268 _main (main.m:16)* 27 libdyld.dylib 0x1805305b8 _start + 4 信息收集先确定下signal 5崩溃的原因是啥，signal.h定义的signal如下： 12345678910111213141516171819202122232425262728293031323334353637383940#define SIGHUP 1 /* hangup */#define SIGINT 2 /* interrupt */#define SIGQUIT 3 /* quit */#define SIGILL 4 /* illegal instruction (not reset when caught) */#define SIGTRAP 5 /* trace trap (not reset when caught) */#define SIGABRT 6 /* abort() */#if (defined(_POSIX_C_SOURCE) &amp;&amp; !defined(_DARWIN_C_SOURCE))#define SIGPOLL 7 /* pollable event ([XSR] generated, not supported) */#else /* (!_POSIX_C_SOURCE || _DARWIN_C_SOURCE) */#define SIGIOT SIGABRT /* compatibility */#define SIGEMT 7 /* EMT instruction */#endif /* (!_POSIX_C_SOURCE || _DARWIN_C_SOURCE) */#define SIGFPE 8 /* floating point exception */#define SIGKILL 9 /* kill (cannot be caught or ignored) */#define SIGBUS 10 /* bus error */#define SIGSEGV 11 /* segmentation violation */#define SIGSYS 12 /* bad argument to system call */#define SIGPIPE 13 /* write on a pipe with no one to read it */#define SIGALRM 14 /* alarm clock */#define SIGTERM 15 /* software termination signal from kill */#define SIGURG 16 /* urgent condition on IO channel */#define SIGSTOP 17 /* sendable stop signal not from tty */#define SIGTSTP 18 /* stop signal from tty */#define SIGCONT 19 /* continue a stopped process */#define SIGCHLD 20 /* to parent on child stop or exit */#define SIGTTIN 21 /* to readers pgrp upon background tty read */#define SIGTTOU 22 /* like TTIN for output if (tp-&gt;t_local&amp;LTOSTOP) */#if (!defined(_POSIX_C_SOURCE) || defined(_DARWIN_C_SOURCE))#define SIGIO 23 /* input/output possible signal */#endif#define SIGXCPU 24 /* exceeded CPU time limit */#define SIGXFSZ 25 /* exceeded file size limit */#define SIGVTALRM 26 /* virtual time alarm */#define SIGPROF 27 /* profiling time alarm */#if (!defined(_POSIX_C_SOURCE) || defined(_DARWIN_C_SOURCE))#define SIGWINCH 28 /* window size changes */#define SIGINFO 29 /* information request */#endif#define SIGUSR1 30 /* user defined signal 1 */#define SIGUSR2 31 /* user defined signal 2 */ SIGTRAP 5 -&gt; trace trap (not reset when caught)根据苹果的文档： Similar to an Abnormal Exit, this exception is intended to give an attached debugger the chance to interrupt the process at a specific point in its execution. You can trigger this exception from your own code using the __builtin_trap() function. If no debugger is attached, the process is terminated and a crash report is generated. Lower-level libraries (e.g, libdispatch) will trap the process upon encountering a fatal error. Additional information about the error can be found in the Additional Diagnostic Information section of the crash report, or in the device’s console. 这种错误也是属于异常错误，不过常用于连接调试器进行调试。某系底层库在遇到严重错误时也会抛出这个错误，例如libdispatch。回看这个崩溃的运行栈，位于最顶端的是__dispatch_queue_resume，也是属于libdispatch这个库，应该是某个地方使用GCD出错。 分析定位崩溃的最后一个函数是__dispatch_queue_resume，可能和dispatch_resume函数有一定的关系，项目中使用地方的印象中应该不多。全局搜索一把，有以下结果：en…….用的地方还是挺多的，那到底是哪一个函数呢？回看崩溃栈： 123456* 7 CoreFoundation 0x18154fbf4 __CFXNotificationPost + 376* 8 Foundation 0x1820566bc -[NSNotificationCenter postNotificationName:object:userInfo:] + 68* 9 UIKit 0x18771d9d8 -[UIApplication _sendWillEnterForegroundCallbacks] + 232* 10 UIKit 0x187758ebc -[UIApplication _handleApplicationActivationWithScene:transitionContext:completion:] + 2140* 11 UIKit 0x1877583ec -[UIApplication _handleApplicationLifecycleEventWithScene:transitionContext:completion:] + 452* 12 UIKit 0x187743ae8 ___70-[UIApplication scene:didUpdateWithDiff:transitionContext:completion:]_block_invoke + 152 这几个函数指明此时App刚进入前台，正在广播ApplicationWillEnterForeground通知，看刚才的搜索结果，可以确认出问题的代码应该在[LEColorPicker appDidEnterForeground:]方法上。 123- (void)appDidEnterForeground:(NSNotification *)notification &#123; dispatch_resume(taskQueue);&#125; dispatch_resume看看此函数注释确认下是参数出错还是用法出发，注释如下：留意圈注的地方，如果dispatch_object已经激活再次调用resume此函数会抛出异常，结束进程。若传入参数为nil，行为不定。结合代码： 123456789101112131415161718192021222324252627282930313233343536dispatch_resume(taskQueue);- (id)init &#123; self = [super init]; if (self) &#123; // Create queue and set working flag initial state taskQueue = dispatch_queue_create(&quot;LEColorPickerQueue&quot;, DISPATCH_QUEUE_SERIAL); dispatch_set_target_queue(taskQueue, dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_LOW, 0)); _isActive = [UIApplication sharedApplication].applicationState == UIApplicationStateActive; // Add notifications for multitasking and background aware [self addNotificationObservers]; &#125; return self;&#125;- (void)addNotificationObservers &#123; // Add observers for notification to respond at app state changes. [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(appDidEnterBackground:) name:UIApplicationDidEnterBackgroundNotification object:nil]; [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(applicationWillResignActive:) name:UIApplicationWillResignActiveNotification object:nil]; [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(appDidEnterForeground:) name:UIApplicationWillEnterForegroundNotification object:nil];&#125;- (void)appDidEnterForeground:(NSNotification *)notification &#123; dispatch_resume(taskQueue);&#125; taskQueue成员变量在实例初始化时就被赋值且没有地方再设置为nil。难道是appDidEnterForeground:回调了两次，导致dispatch_resume(taskQueue);被调用了两次？ 12* 2 CoreFoundation 0x18160e22c ___CFNOTIFICATIONCENTER_IS_CALLING_OUT_TO_AN_OBSERVER__ + 20* 3 CoreFoundation 0x18160e22c ___CFNOTIFICATIONCENTER_IS_CALLING_OUT_TO_AN_OBSERVER__ + 20 崩溃栈的两个连续函数调用证明了appDidEnterForeground:回调了两次。 真相？？如果是addNotificationObservers被调用了两次，applicationWillResignActive:和appDidEnterForeground:都会被调用两次，dispatch_suspend和dispatch_resume的调用次数应该是匹配的，不会出现dispatch_resume次数大于dispatch_suspend的情况。难道是NSNotifictaion的Bug？搜索了CoreFoundation的源码也没有发现__CFXRegistrationPost相关的类。en………… 临时的解决方法…..1234567891011- (void)applicationWillResignActive:(NSNotification *)notification &#123; dispatch_suspend(taskQueue); _taskQueueSuspended = YES;&#125;- (void)appDidEnterForeground:(NSNotification *)notification &#123; if (_taskQueueSuspended) &#123; dispatch_resume(taskQueue); _taskQueueSuspended = NO; &#125;&#125; 打个标记，仅在标记开启时才调用dispatch_resume😂。 几个版本之后的结果此崩溃没有再出现过，但是根本原因还是没能找到……","categories":[{"name":"踩坑记录","slug":"踩坑记录","permalink":"http://yoursite.com/categories/踩坑记录/"},{"name":"崩溃定位及预防","slug":"踩坑记录/崩溃定位及预防","permalink":"http://yoursite.com/categories/踩坑记录/崩溃定位及预防/"}],"tags":[{"name":"踩坑记录","slug":"踩坑记录","permalink":"http://yoursite.com/tags/踩坑记录/"},{"name":"崩溃分析","slug":"崩溃分析","permalink":"http://yoursite.com/tags/崩溃分析/"}]},{"title":"iOS崩溃crash收集及分析","slug":"iOSCrashAnalyze","date":"2017-12-06T10:44:48.000Z","updated":"2017-12-11T07:05:53.423Z","comments":true,"path":"2017/12/06/iOSCrashAnalyze/","link":"","permalink":"http://yoursite.com/2017/12/06/iOSCrashAnalyze/","excerpt":"前言崩溃的出现意味着代码出现了问题，通常的解决路径是根据测试/用户/日志文件的行为描述，试图重现崩溃，定位到具体的代码位置，分析出现的原因，找到根治的办法，最后验证解决方案以确认崩溃被修复。那么我们该如何去搜集、分析、解决崩溃呢，请看下文。","text":"前言崩溃的出现意味着代码出现了问题，通常的解决路径是根据测试/用户/日志文件的行为描述，试图重现崩溃，定位到具体的代码位置，分析出现的原因，找到根治的办法，最后验证解决方案以确认崩溃被修复。那么我们该如何去搜集、分析、解决崩溃呢，请看下文。 如何收集崩溃信息？官方渠道XCode Organizer在Xcode-&gt;Window-&gt;Organizer选择已上架的App看以查看到每个版本中App的崩溃情况，如下图：优点： 自动符号化崩溃栈，甚至可以直接打开项目，跳转到相关文件代码 缺点： 只有崩溃数量及不同机型/系统下的占比，没有崩溃率。 只有崩溃栈信息，没有当时用户的操作记录，对于像上图中的崩溃，仅有崩溃栈信息，很难下手处理。 第三方服务：听云/Bugly/友盟听云听云收集的崩溃信息如下：听云记录的信息比较全面，包含崩溃率统计、崩溃栈、崩溃轨迹。 BuglyBugly收集的信息如下：Bugly收集到的信息包含崩溃率统计、崩溃栈，可以关联崩溃时的记录的日志。在日志中记录VC的打开记录，实现类似于听云的崩溃轨迹记录。 友盟友盟收集的信息如下：友盟收集到的信息包含崩溃率统计、崩溃栈。 小结优点： 除了崩溃时的运行栈外，还可以附带当时用户的使用轨迹！这非常有利于我们重建当时的崩溃场景！（友盟除外） 缺点： 需要自行上传DSYM文件。 对App有一定的入侵，可以抓取到App行为信息。 DIY自行构建使用如KSCrash或干脆自己写一个崩溃监测库，实现类似于上述第三方服务的功能。优点当然是可以实现任意想要的功能，但是开发成本比较大。 如何符号化崩溃信息？1234567891011120 CoreFoundation 0x0000000183491d1c &lt;redacted&gt; + 1481 libobjc.A.dylib 0x00000001826e0528 objc_exception_throw + 562 CoreFoundation 0x0000000183491c4c &lt;redacted&gt; + 03 YouAppsBinary 0x100817c80 YouAppsBinary + 84860164 libsystem_platform.dylib 0x00000001830b7b34 _sigtramp + 365 MediaToolbox 0x0000000187982300 FigPhotoJPEGShouldUseHardwareDecode + 766 ImageIO 0x00000001853e87ec &lt;redacted&gt; + 1887 ImageIO 0x00000001853e9180 &lt;redacted&gt; + 3128 ImageIO 0x00000001855447b0 &lt;redacted&gt; + 809 ImageIO 0x0000000185542d8c &lt;redacted&gt; + 10810 ImageIO 0x00000001853cac88 &lt;redacted&gt; + 31211 ImageIO 0x00000001853c8554 &lt;redacted&gt; + 428 在没有符号化崩溃信息之前，我们只能看到包含镜像名+函数内存地址的崩溃栈，没法得知具体的崩溃函数及行号，这时就需要使用DSYM文件对崩溃信息进行符号化。 DSYM文件XCode编译项目之后，会在yourApp.app同步目录下生成一个yourApp.app.dsym的bundle，里面包含了16进制函数地址映射到源文件函数行号的中转文件。有了这个文件，就可以将内存地址转换为崩溃发生时的源文件及行号。每个版本的app/dsym都有唯一匹配的UUID，只有当两者UUID唯一匹配时，16进制符号化出来的信息才是正确的。app/dysm的UUID可以使用以下命令查看。 12dwarfdump --uuid /xx/xx.appdwarfdump --uuid /xx/xx.app.dsym 如何符号化xcode的organizer的可以自动符号化它所及收集到的崩溃信息。将匹配的dsym文件上传到听云/Bugly，也可以得到符号化的崩溃信息。若想自己查看也可以通过以下命令查看: 1xcrun atos -arch arm64 -o /xxxx/xxx.app.dsym 函数地址 如何分析崩溃信息？这里有一篇不错的崩溃分析文章，可以详细参考下。 常见的崩溃原因及解决方案集合类插入nil/越界访问这些类型崩溃崩溃栈都有很明显的特征，栈顶附近通常带有_objc_exception_throw调用，为App没有处理相关异常，App最终崩溃。像听云/Bugly等第三发服务，会将异常信息打印出来，方便定位。如下： 121、[NSPlaceholderString initWithFormat:locale:arguments:]: nil argument 2、setObjectForKey: object cannot be nil 解决办法： 追踪异常数据的来源，从源头上堵住异常数据。避免一处加了保护，导致脏数据流向别的流程，出发其他异常。 给所有集合类加上nil/越界访问保护，例如定义一些Category或替换一些不安全的方法。但要加上合适的断言/上报机制，尽快发现和处理这种异常情况。 unrecognized selector出现这种崩溃的原因通常为： 调用了高版本系统API 业务处理逻辑未考虑到某些异常情况，强转类型出错。这种问题很容易出现在含复杂状态管理的业务里 解决办法： 对于第一种情况，在使用不熟悉的API时，要留意一下可用的系统版本。此外在使用高系统版本的API时，XCode 9会出现警告，多留意一下即可。 取决于细不细心啰。 或者利用objc的消息转发机制，动态添加未知的selector的实现。但是这种方法有缺陷，在未知selector的转发流程中，我们拿到的只有selector，没有方法实现，因此我们不知道此selctor的返回值类型是什么。假设我们默认返回nil，若此selector原本返回的是对象，则有可能不崩溃。若此selector原本返回的是block/结构体，就会导致别的崩溃。 Application received signal 11/SIGSEGV出现了非法内存访问，例如 123456Application received signal 11 1. libobjc.A.dylib 0x1800b9b88 _objc_msgSend + 8 2. CoreFoundation 0x180a3f1b8 ___rehashd + 152 3. CoreFoundation 0x180928468 -[__NSDictionaryM setObject:forKey:] + 688 4. app. 0x10027ba04 [BaseDataModel initialize] (BaseDataModel.m:31) 出现这种崩溃的原因通常为： 使用了assign作为修饰符，在对象释放之后，仍然进行访问。 不同线程同时操作可变集合类/赋值同一个成员变量。 解决办法： 在合适的时候置为nil或改为用weak修饰。某些系统API，如CBCentralManager的delegate属性在iOS 11上声明为weak，然而在旧版本上缺声明为assign，所以遇到系统给的delegate，在dealloc时，最好设置为nil。 涉及线程管理，后续再做讨论。 参考文章 Understanding and Analyzing Application Crash Reports iOS崩溃crash大解析 如何定位Obj-C野指针随机Crash系列 小萝莉说Crash系列","categories":[{"name":"崩溃定位及预防","slug":"崩溃定位及预防","permalink":"http://yoursite.com/categories/崩溃定位及预防/"}],"tags":[{"name":"崩溃分析","slug":"崩溃分析","permalink":"http://yoursite.com/tags/崩溃分析/"},{"name":"崩溃定位","slug":"崩溃定位","permalink":"http://yoursite.com/tags/崩溃定位/"}]}]}